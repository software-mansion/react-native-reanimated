"use strict";(globalThis.webpackChunkdocs_worklets=globalThis.webpackChunkdocs_worklets||[]).push([[5475],{29083:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>s});const t=JSON.parse('{"id":"memory/synchronizable","title":"Synchronizable","description":"Synchronizable is a type of shared memory not tied to any JavaScript Runtime. It can be accessed from any JavaScript Runtime and C++. The value held by Synchronizable behaves like a standard JavaScript value.","source":"@site/docs/memory/synchronizable.mdx","sourceDirName":"memory","slug":"/memory/synchronizable","permalink":"/react-native-worklets/docs/memory/synchronizable","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-reanimated/edit/main/docs/docs-worklets/docs/memory/synchronizable.mdx","tags":[],"version":"current","sidebarPosition":42,"frontMatter":{"id":"synchronizable","title":"Synchronizable","sidebar_position":42},"sidebar":"tutorialSidebar","previous":{"title":"Serializable","permalink":"/react-native-worklets/docs/memory/serializable"},"next":{"title":"makeShareable","permalink":"/react-native-worklets/docs/memory/makeShareable"}}');var o=i(47671),l=i(30620);const a={id:"synchronizable",title:"Synchronizable",sidebar_position:42},r="Synchronizable ",c={},s=[{value:"Reference",id:"reference",level:2},{value:"Methods",id:"methods",level:2},{value:"getBlocking",id:"getblocking",level:3},{value:"getDirty",id:"getdirty",level:3},{value:"setBlocking",id:"setblocking",level:3},{value:"lock",id:"lock",level:3},{value:"unlock",id:"unlock",level:3},{value:"C++ integration",id:"c-integration",level:2},{value:"Remarks",id:"remarks",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components},{AvailableFrom:t,Details:a,SVGDiagram:r}=n;return t||u("AvailableFrom",!0),a||u("Details",!0),r||u("SVGDiagram",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsxs)(n.h1,{id:"synchronizable-",children:["Synchronizable ",(0,o.jsx)(t,{version:"0.6.0"})]})}),"\n",(0,o.jsx)(n.p,{children:"Synchronizable is a type of shared memory not tied to any JavaScript Runtime. It can be accessed from any JavaScript Runtime and C++. The value held by Synchronizable behaves like a standard JavaScript value."}),"\n",(0,o.jsx)(n.p,{children:"You can use Synchronizable on multiple Runtimes to poll some shared state information without expensive synchronous messaging between Runtimes."}),"\n",(0,o.jsx)(n.p,{children:"Synchronizable can be accessed both non-exclusively or exclusively - meaning that a thread (Runtime) could obtain it and all other threads (Runtimes) trying to access it will have to wait until it's released."}),"\n",(0,o.jsx)(r,{children:(0,o.jsx)(n.img,{alt:"Synchronizable",src:i(64845).A+"",width:"1456",height:"438"})}),"\n",(0,o.jsx)("figcaption",{style:{textAlign:"center"},children:(0,o.jsx)(n.p,{children:"Synchronizable memory model"})}),"\n",(0,o.jsxs)(a,{children:[(0,o.jsx)("summary",{children:"Type definitions"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"type Synchronizable<TValue = unknown> = {\n  getDirty(): TValue;\n  getBlocking(): TValue;\n  setBlocking(value: TValue | ((prev: TValue) => TValue)): void;\n  lock(): void;\n  unlock(): void;\n};\n"})})]}),"\n",(0,o.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { createSynchronizable, scheduleOnUI } from 'react-native-worklets';\n\n// RN Runtime, JS thread\n\nconst synchronizable = createSynchronizable({ a: 42 });\n\nscheduleOnUI(() => {\n  // UI Runtime, UI thread\n  const value = synchronizable.getBlocking();\n  console.log(value); // {a: 24}\n});\n\n// Could execute either before or after the UI Runtime reads the value.\nsynchronizable.setBlocking({ a: 24 });\n"})}),"\n",(0,o.jsx)(r,{children:(0,o.jsx)(n.img,{alt:"Synchronizable flow",src:i(59998).A+"",width:"1950",height:"683"})}),"\n",(0,o.jsx)("figcaption",{style:{textAlign:"center"},children:(0,o.jsxs)(n.p,{children:["Possible flow of operations for the above example, assuming that ",(0,o.jsx)(n.code,{children:"getBlocking"}),"\nfunction executes first. Time axis is not to scale."]})}),"\n",(0,o.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,o.jsx)(n.p,{children:"Synchronizable has the following methods to access and modify its value:"}),"\n",(0,o.jsx)(n.h3,{id:"getblocking",children:"getBlocking"}),"\n",(0,o.jsxs)(n.p,{children:["Exclusively obtains the Synchronizable and returns its value, potentially blocking if ",(0,o.jsx)(n.code,{children:"getBlocking"})," or ",(0,o.jsx)(n.code,{children:"setBlocking"})," are being executed on another thread or if the Synchronizable is explicitly locked."]}),"\n",(0,o.jsx)(n.h3,{id:"getdirty",children:"getDirty"}),"\n",(0,o.jsxs)(n.p,{children:["Non-exclusively obtains the Synchronizable and returns its value. It never blocks, even if the Synchronizable is explicitly locked, therefore could result in a ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Write%E2%80%93read_conflict",children:"dirty read"}),". Useful for scenarios where eventual consistency is acceptable."]}),"\n",(0,o.jsx)(n.h3,{id:"setblocking",children:"setBlocking"}),"\n",(0,o.jsxs)(n.p,{children:["Exclusively obtains the Synchronizable and sets it to the provided value, potentially blocking if either ",(0,o.jsx)(n.code,{children:"getBlocking"})," or ",(0,o.jsx)(n.code,{children:"setBlocking"})," are being executed or if the Synchronizable is explicitly locked. You can also pass a setter function that receives the previous value and returns the new value. Synchronizable is ",(0,o.jsx)(n.strong,{children:"locked for the duration of the setter function execution"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"// Set the value to 42\nsynchronizable.setBlocking(42);\n// Increment the value by 1\nsynchronizable.setBlocking((prev) => prev + 1);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The value provided to ",(0,o.jsx)(n.code,{children:"setBlocking"})," is serialized automatically."]}),"\n",(0,o.jsx)(n.h3,{id:"lock",children:"lock"}),"\n",(0,o.jsxs)(n.p,{children:["Exclusively locks the Synchronizable - other threads are blocked when calling ",(0,o.jsx)(n.code,{children:"getBlocking"}),", ",(0,o.jsx)(n.code,{children:"setBlocking"})," or ",(0,o.jsx)(n.code,{children:"lock"})," until the Synchronizable is unlocked. Multiple calls on the same thread do nothing."]}),"\n",(0,o.jsx)(n.h3,{id:"unlock",children:"unlock"}),"\n",(0,o.jsx)(n.p,{children:"Unlocks the Synchronizable. Does nothing on already unlocked Synchronizable. Works only when called from the same thread which locked the Synchronizable. Forgetting to unlock a Synchronizable could lead to deadlocks."}),"\n",(0,o.jsx)(n.h2,{id:"c-integration",children:"C++ integration"}),"\n",(0,o.jsx)(n.p,{children:"Synchronizable can be created and accessed from C++ code. The C++ API doesn't support setter functions."}),"\n",(0,o.jsx)(n.h2,{id:"remarks",children:"Remarks"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["While Synchronizable can hold any ",(0,o.jsx)(n.a,{href:"/docs/memory/serializable",children:"Serializable"})," JavaScript value, we recommend to use primitives like ",(0,o.jsx)(n.code,{children:"number"}),", ",(0,o.jsx)(n.code,{children:"string"})," or ",(0,o.jsx)(n.code,{children:"boolean"})," for best performance, to minimize the amount of data being copied for each access."]}),"\n",(0,o.jsx)(n.li,{children:"We recommend to avoid changing the type of the value held by Synchronizable, instead opt to create a new Synchronizable for different types."}),"\n",(0,o.jsx)(n.li,{children:"Synchronizable is not reactive, meaning that there are no built-in mechanisms to notify Runtimes when its value changes. Runtimes need to poll the value to detect changes."}),"\n",(0,o.jsx)(n.li,{children:"Synchronizable on a JavaScript Runtime is a wrapper to a reference to the actual Synchronizable living in C++. The value held by Synchronizable is copied to/from C++ on each access."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},30620:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var t=i(39471);const o={},l=t.createContext(o);function a(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(l.Provider,{value:n},e.children)}},59998:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/synchronizable-flow-c68926c51c312a7c99e11ec92810456d.svg"},64845:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/synchronizable-7d3b3e3e236f17e5f5cbe87e4fcd31d1.svg"}}]);