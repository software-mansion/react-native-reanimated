"use strict";(globalThis.webpackChunkdocs_worklets=globalThis.webpackChunkdocs_worklets||[]).push([[2321],{30620:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var i=n(39471);const r={},a=i.createContext(r);function s(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:t},e.children)}},58031:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"memory/registerCustomSerializable","title":"registerCustomSerializable","description":"registerCustomSerializable lets you register your own pre-serialization and post-deserialization logic. This is necessary for objects with prototypes different than just Object.prototype or some other built-in prototypes like Map etc. Worklets can\'t handle such objects by default to convert into Serializables hence you need to register them as Custom Serializables. This way you can tell Worklets how to transfer your custom data structures between different Runtimes without manually serializing and deserializing them every time.","source":"@site/docs/memory/registerCustomSerializable.mdx","sourceDirName":"memory","slug":"/memory/registerCustomSerializable","permalink":"/react-native-worklets/docs/memory/registerCustomSerializable","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-reanimated/edit/main/docs/docs-worklets/docs/memory/registerCustomSerializable.mdx","tags":[],"version":"current","sidebarPosition":42,"frontMatter":{"title":"registerCustomSerializable","sidebar_position":42},"sidebar":"tutorialSidebar","previous":{"title":"isSynchronizable","permalink":"/react-native-worklets/docs/memory/isSynchronizable"},"next":{"title":"Serializable","permalink":"/react-native-worklets/docs/memory/serializable"}}');var r=n(47671),a=n(30620);const s={title:"registerCustomSerializable",sidebar_position:42},o="registerCustomSerializable ",l={},c=[{value:"Reference",id:"reference",level:2},{value:"Arguments",id:"arguments",level:2},{value:"registrationData",id:"registrationdata",level:3},{value:"Motivation",id:"motivation",level:2},{value:"Remarks",id:"remarks",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components},{AvailableFrom:n,Details:i}=t;return n||h("AvailableFrom",!0),i||h("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsxs)(t.h1,{id:"registercustomserializable-",children:["registerCustomSerializable ",(0,r.jsx)(n,{version:"0.7.0"})]})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"registerCustomSerializable"})," lets you register your own pre-serialization and post-deserialization logic. This is necessary for objects with prototypes different than just ",(0,r.jsx)(t.code,{children:"Object.prototype"})," or some other built-in prototypes like ",(0,r.jsx)(t.code,{children:"Map"})," etc. Worklets can't handle such objects by default to convert into ",(0,r.jsx)(t.a,{href:"/docs/memory/serializable",children:"Serializables"})," hence you need to register them as ",(0,r.jsx)(t.strong,{children:"Custom Serializables"}),". This way you can tell Worklets how to transfer your custom data structures between different Runtimes without manually serializing and deserializing them every time."]}),"\n",(0,r.jsxs)(t.p,{children:["List of supported types for Serialization can be found ",(0,r.jsx)(t.a,{href:"/docs/memory/serializable#supported-types",children:"here"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"reference",children:"Reference"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"const obj = { a: 42 };\nObject.setPrototypeOf(obj, console); // because why not\n\ntype ConsoleLike = typeof console;\n\nregisterCustomSerializable({\n  name: 'ConsoleLike',\n  determine(value: object): value is ConsoleLike {\n    'worklet';\n    return Object.getPrototypeOf(value) === console;\n  },\n  pack(value: ConsoleLike) {\n    'worklet';\n    return { a: value.a }; // transfer data\n  },\n  unpack(value: object) {\n    'worklet';\n    // recreate object with prototype\n    return Object.create(console, value);\n  },\n});\n"})}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)("summary",{children:"Type definitions"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"function registerCustomSerializable<\n  TValue extends object,\n  TPacked extends object,\n>(registrationData: RegistrationData<TValue, TPacked>): void;\n\ntype RegistrationData<TValue extends object, TPacked = unknown> = {\n  name: string;\n  determine: (value: object) => value is TValue;\n  pack: (value: TValue) => TPacked;\n  unpack: (value: TPacked) => TValue;\n};\n"})})]}),"\n",(0,r.jsx)(t.h2,{id:"arguments",children:"Arguments"}),"\n",(0,r.jsx)(t.h3,{id:"registrationdata",children:"registrationData"}),"\n",(0,r.jsx)(t.p,{children:"An object containing the registration data for the Custom Serializable."}),"\n",(0,r.jsx)(t.p,{children:"Available properties:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"name"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"string"})}),(0,r.jsx)(t.td,{children:"A unique name for the Custom Serializable. It's used to prevent duplicate registrations of the same Custom Serializable. You will get warned if you attempt to register a Custom Serializable with a name that has already been used."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"determine"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"(value: object) => value is TValue"})}),(0,r.jsxs)(t.td,{children:["A ",(0,r.jsx)(t.a,{href:"/docs/fundamentals/glossary#worklet",children:"worklet"})," that checks whether a given JavaScript value is of the type handled by this Custom Serializable."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"pack"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"(value: TValue) => TPacked"})}),(0,r.jsxs)(t.td,{children:["A ",(0,r.jsx)(t.a,{href:"/docs/fundamentals/glossary#worklet",children:"worklet"})," that packs the JavaScript value of type ",(0,r.jsx)(t.code,{children:"TValue"})," into a value that can be serialized by default as ",(0,r.jsx)(t.a,{href:"/docs/memory/serializable",children:"Serializable"}),". The function must return a ",(0,r.jsx)(t.a,{href:"/docs/memory/serializable#supported-types",children:"supported type for Serialization"}),"."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"unpack"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"(value: TPacked) => TValue"})}),(0,r.jsxs)(t.td,{children:["A ",(0,r.jsx)(t.a,{href:"/docs/fundamentals/glossary#worklet",children:"worklet"})," that unpacks the packed value, after it's been deserialized from it's packed form, back into the JavaScript value of type ",(0,r.jsx)(t.code,{children:"TValue"}),"."]})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,r.jsx)(t.p,{children:"Custom prototypes are bound to a single Runtime and don't exist in other Runtimes. Due to that it's impossible to transfer them between runtimes directly. This is why a pre-serialization (packing) and pre-deserialization (unpacking) logic is required."}),"\n",(0,r.jsx)(t.p,{children:"Consider the following examples:"}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsxs)("tr",{style:{padding:"20px"},children:[(0,r.jsx)("td",{children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"const obj = {};\n\n// because why not\nObject.setPrototypeOf(obj, console);\n\nscheduleOnUI(() => {\n  // This will throw because `obj`\n  // had a custom prototype and\n  // it couldn't be serialized.\n  obj.log('Hello!');\n});\n"})})}),(0,r.jsx)("td",{style:{textAlign:"center",flex:1},children:(0,r.jsx)(t.mermaid,{value:'flowchart TD\n    A[obj] --\x3e|automatic serialization| B[no known serialization method, serialized as a dummy value]\n    B --\x3e|scheduleOnUI| C[transferred to UI Runtime]\n    C --\x3e|automatic deserialization| D[deserialized from a dummy value]\n    D --\x3e|"obj.log(\'Hello!\')"| E["<b>Error: serialization failed</b>"]\n    style E fill:#ff000022,stroke:#990000'})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"const obj = {};\n\n// because why not\nObject.setPrototypeOf(obj, console);\n\ntype ConsoleLike = typeof console;\n\nregisterCustomSerializable({\n  name: 'ConsoleLike',\n  determine(value: object): value is ConsoleLike {\n    'worklet';\n    return Object.getPrototypeOf(value) === console;\n  },\n  pack(value: ConsoleLike) {\n    'worklet';\n    // We don't need to transfer any data,\n    // so we can pack it to an empty object.\n    return {};\n  },\n  unpack(value: object) {\n    'worklet';\n    // We can recreate the original object.\n    return Object.create(console);\n  },\n});\n\nscheduleOnUI(() => {\n  obj.log('Hello!'); // prints 'Hello!'\n});\n"})})}),(0,r.jsx)("td",{style:{textAlign:"center",flex:1},children:(0,r.jsx)(t.mermaid,{value:"flowchart TD\n  A[obj] --\x3e|automatic serialization| B[identified as a Custom Serializable '<i>ConsoleLike</i>']\n  subgraph S1 [ ]\n    B --\x3e|pack| C[packed with Custom Serializable's pack method]\n  end\n  C --\x3e|actual serialization| D[serialized packed object as a default supported type]\n    D --\x3e|scheduleOnUI| E[transferred to Runtime B]\n    E --\x3e|automatic deserialization| F[deserialized to the packed object]\n    F --\x3e|unpack| G\n  subgraph S2 [ ]\n    G[unpacked with Custom Serializable's unpack method]\n  end\n    G --\x3e|\"obj.log('Hello!')\"| H[\"<b>'Hello!'</b> printed to console\"]\n    style H fill:#00ff0022,stroke:#009900"})})]})]}),"\n",(0,r.jsx)(t.h2,{id:"remarks",children:"Remarks"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["To use Custom Serializables which require ",(0,r.jsx)(t.code,{children:"new"})," keyword for instantiation, you need to ",(0,r.jsx)(t.a,{href:"/docs/worklets-babel-plugin/plugin-options#disableworkletclasses-",children:"disable Worklet Classes"})," option in Worklets Babel plugin configuration."]}),"\n",(0,r.jsxs)(t.li,{children:["Custom Serializables are global and shared between all ",(0,r.jsx)(t.a,{href:"/docs/fundamentals/runtimeKinds#worklet-runtime",children:"Worklet Runtimes"}),". Once you register a Custom Serializable, it will be available in all Runtimes."]}),"\n",(0,r.jsxs)(t.li,{children:["You can use ",(0,r.jsx)(t.code,{children:"registerCustomSerializable"})," only on the ",(0,r.jsx)(t.a,{href:"/docs/fundamentals/runtimeKinds#rn-runtime",children:"RN Runtime"}),"."]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}function h(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);