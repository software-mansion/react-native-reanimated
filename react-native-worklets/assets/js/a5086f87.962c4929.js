"use strict";(globalThis.webpackChunkdocs_worklets=globalThis.webpackChunkdocs_worklets||[]).push([[518],{30620:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>i});var o=s(39471);const t={},r=o.createContext(t);function l(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),o.createElement(r.Provider,{value:n},e.children)}},83496:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"fundamentals/closures","title":"Understanding closures","description":"What are closures in worklets?","source":"@site/docs/fundamentals/closures.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/closures","permalink":"/react-native-worklets/docs/fundamentals/closures","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-reanimated/edit/main/docs/docs-worklets/docs/fundamentals/closures.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Glossary of terms","permalink":"/react-native-worklets/docs/fundamentals/glossary"},"next":{"title":"Runtime kinds","permalink":"/react-native-worklets/docs/fundamentals/runtimeKinds"}}');var t=s(47671),r=s(30620);const l={sidebar_position:3},i="Understanding closures",a={},c=[{value:"What are closures in worklets?",id:"what-are-closures-in-worklets",level:2},{value:"Closure behavior on the same JavaScript Runtime",id:"closure-behavior-on-the-same-javascript-runtime",level:2},{value:"Closure behavior across different JavaScript Runtimes",id:"closure-behavior-across-different-javascript-runtimes",level:2},{value:"Global scoping",id:"global-scoping",level:2}];function u(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"understanding-closures",children:"Understanding closures"})}),"\n",(0,t.jsx)(n.h2,{id:"what-are-closures-in-worklets",children:"What are closures in worklets?"}),"\n",(0,t.jsxs)(n.p,{children:["What makes ",(0,t.jsx)(n.a,{href:"/docs/fundamentals/glossary#worklet",children:"worklets"})," special is their ",(0,t.jsx)(n.strong,{children:"ability to capture variables from their surrounding scope"}),", similar to regular JavaScript functions. This feature is known as ",(0,t.jsx)(n.em,{children:"closures"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["While a closure is ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures",children:"defined as both the function and its lexical environment"}),", here we will refer to closures as just the captured variables from the surrounding ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Scope",children:"scope"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"const a = 1;\nconst b = 2;\nconst c = 3;\n\nfunction addAB() {\n  'worklet';\n  return a + b + c;\n  // You can access `a` and `b` and `c` here\n  // because they are captured from the surrounding scope.\n\n  // We will refer to `a`, `b`, and `c` as the closure of this worklet.\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"However, there are some important differences in how closures work in worklets compared to regular JavaScript functions."}),"\n",(0,t.jsx)(n.h2,{id:"closure-behavior-on-the-same-javascript-runtime",children:"Closure behavior on the same JavaScript Runtime"}),"\n",(0,t.jsxs)(n.p,{children:["If you call a worklet on the same runtime where it's defined (the ",(0,t.jsx)(n.a,{href:"/docs/fundamentals/runtimeKinds#rn-runtime",children:"React Native Runtime"}),"), its closure gets copies of references to the original variables. This means that reassigning the original variable will not affect the value inside the worklet."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"let count = 0;\n\nfunction logCount() {\n  'worklet';\n  console.log(count); // Always prints 0, even if `count` changes later.\n}\n\ncount = 1;\nlogCount(); // prints 0\n"})}),"\n",(0,t.jsx)(n.p,{children:"This works both ways, so if you reassign inside a worklet, it won't affect the original variable in the surrounding scope."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"let count = 0;\n\nfunction increment() {\n  'worklet';\n  count += 1; // This modifies the copy of `count`, not the original.\n}\n\nincrement();\nconsole.log(count); // Still prints 0\n"})}),"\n",(0,t.jsx)(n.p,{children:"The behavior is slightly different for object (non-primitive) references:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Reassigning the reference in the surrounding scope does not affect the worklet's closure."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"let obj = { value: 0 };\n\nfunction logValue() {\n  'worklet';\n  console.log(obj.value);\n}\n\nobj = { value: 1 };\nlogValue(); // Prints 0\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Mutating the object inside the worklet affects the object in the surrounding scope, since they reference the same object."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"let obj = { value: 0 };\n\nfunction mutate() {\n  'worklet';\n  obj.value += 1;\n}\n\nmutate();\nconsole.log(obj.value); // Prints 1\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Mutating the object in the surrounding scope affects the object inside the worklet, since they reference the same object."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"let obj = { value: 0 };\n\nfunction logValue() {\n  'worklet';\n  console.log(obj.value);\n}\n\nobj.value = 1;\nlogValue(); // Prints 1\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"closure-behavior-across-different-javascript-runtimes",children:"Closure behavior across different JavaScript Runtimes"}),"\n",(0,t.jsxs)(n.p,{children:["When a worklet is executed in a different JavaScript runtime than the Runtime of its origin (a ",(0,t.jsx)(n.a,{href:"/docs/fundamentals/runtimeKinds#worklet-runtime",children:"Worklet Runtime"}),"), the closure behavior is different again. ",(0,t.jsx)(n.strong,{children:"The closure in the worklet becomes an exact copy of the variables from the surrounding scope at the moment of its invocation."})," This is a necessity due to the fact that different runtimes cannot share references to the same objects, they cannot share memory directly."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"let obj = { value: 0 };\n\nfunction logValue() {\n  'worklet';\n  console.log(obj.value);\n}\n\nobj.value = 1;\nrunOnUISync(logValue); // Prints 0\n"})}),"\n",(0,t.jsx)(n.h2,{id:"global-scoping",children:"Global scoping"}),"\n",(0,t.jsxs)(n.p,{children:["In the previous examples we used ",(0,t.jsx)(n.code,{children:"console"})," inside worklets. Where does it come from?"]}),"\n",(0,t.jsxs)(n.p,{children:["In JavaScript, when you use a variable (an ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Identifier",children:"identifier"}),") which isn't defined in the local ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Scope",children:"scope"})," (i.e. inside the function), the JavaScript engine looks for it in the outer scopes, eventually reaching the ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Global_scope",children:"global scope"}),". The key point here is that each Worklet Runtime has its own, distinct global scope. This means that global variables are not shared between different runtimes."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["The accessed ",(0,t.jsx)(n.code,{children:"console"})," object inside a worklet is different on each Runtime!"]})," It's available on every runtime because each Worklet Runtime defines its own ",(0,t.jsx)(n.code,{children:"console"})," object in its global scope."]}),"\n",(0,t.jsxs)(n.p,{children:["When you use a global variable inside a worklet, and invoke it on a runtime - it will access the global scope of that runtime, not the global scope of the original JavaScript Runtime. If the variable doesn't exist in the target runtime's global scope, it will be ",(0,t.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"global.someValue = 42;\n\nfunction logSomeValue() {\n  'worklet';\n  console.log(global.someValue);\n}\n\nlogSomeValue(); // Prints 42\n// `global` on the UI Runtime doesn't have `someValue`.\nrunOnUISync(logSomeValue); // Prints undefined\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To have access to a (copy of a) global variable inside a worklet on a different runtime, you must explicitly assign it to the ",(0,t.jsx)(n.code,{children:"global"})," object on the original runtime. This can be done with a local reference in the closure:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"global.someValue = 42;\n// Assign to a local variable to capture it in the closure.\nconst localSomeValue = global.someValue;\n\nfunction assignGlobal() {\n  'worklet';\n  // Assign to the worklet's global scope.\n  global.someValue = localSomeValue;\n}\n\nrunOnUISync(assignGlobal);\n\nfunction logSomeValue() {\n  'worklet';\n  console.log(global.someValue);\n}\n\nrunOnUISync(logSomeValue); // Prints 42\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}}}]);