{
  "version": 3,
<<<<<<< HEAD
  "sources": ["../src/commonObjects.ts", "../src/utils.ts", "../src/asserts.ts", "../src/makeWorklet.ts", "../src/processWorkletObjectMethod.ts", "../src/processIfWorkletFunction.ts", "../src/processForCalleesWorklets.ts", "../src/processIfWorkletNode.ts", "../src/processIfGestureHandlerEventCallbackFunctionNode.ts", "../src/processInlineStylesWarning.ts", "../src/injectVersion.ts", "../src/plugin.ts"],
  "sourcesContent": ["export const globals = new Set([\n  'this',\n  'console',\n  'performance',\n  'Date',\n  'Array',\n  'ArrayBuffer',\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'HermesInternal',\n  'JSON',\n  'Math',\n  'Number',\n  'Object',\n  'String',\n  'Symbol',\n  'undefined',\n  'null',\n  'UIManager',\n  'requestAnimationFrame',\n  'setImmediate',\n  'queueMicrotask',\n  '_WORKLET',\n  'arguments',\n  'Boolean',\n  'parseInt',\n  'parseFloat',\n  'Map',\n  'WeakMap',\n  'WeakRef',\n  'Set',\n  '_log',\n  '_scheduleOnJS',\n  '_makeShareableClone',\n  '_updateDataSynchronously',\n  'eval',\n  '_updatePropsPaper',\n  '_updatePropsFabric',\n  '_removeShadowNodeFromRegistry',\n  'RegExp',\n  'Error',\n  'ErrorUtils',\n  'global',\n  '_measure',\n  '_scrollTo',\n  '_dispatchCommand',\n  '_setGestureState',\n  '_getCurrentTime',\n  'isNaN',\n  'LayoutAnimationRepository',\n  '_notifyAboutProgress',\n  '_notifyAboutEnd',\n]);\n", "export function isRelease() {\n  return (\n    process.env.BABEL_ENV &&\n    ['production', 'release'].includes(process.env.BABEL_ENV)\n  );\n}\n", "export function assertIsDefined<T>(value: T): asserts value is NonNullable<T> {\n  if (value === undefined || value === null) {\n    throw new Error(`${value} is not defined`);\n  }\n}\n", "import {\n  BabelFileResult,\n  NodePath,\n  transformSync,\n  traverse,\n  Node as BabelNode,\n} from '@babel/core';\nimport generate from '@babel/generator';\nimport {\n  ObjectMethod,\n  isObjectMethod,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  identifier,\n  Identifier,\n  objectProperty,\n  isArrowFunctionExpression,\n  variableDeclaration,\n  variableDeclarator,\n  cloneNode,\n  isBlockStatement,\n  functionExpression,\n  objectExpression,\n  stringLiteral,\n  isFunctionDeclaration,\n  VariableDeclaration,\n  ExpressionStatement,\n  ReturnStatement,\n  expressionStatement,\n  assignmentExpression,\n  memberExpression,\n  numericLiteral,\n  arrayExpression,\n  newExpression,\n  returnStatement,\n  blockStatement,\n  isFunctionExpression,\n  isIdentifier,\n  File as BabelTypesFile,\n  objectPattern,\n  thisExpression,\n  isExpression,\n  isExpressionStatement,\n} from '@babel/types';\nimport * as fs from 'fs';\nimport * as convertSourceMap from 'convert-source-map';\nimport { ReanimatedPluginPass } from './types';\nimport { isRelease } from './utils';\nimport { globals } from './commonObjects';\nimport { assertIsDefined } from './asserts';\n\nfunction hash(str: string) {\n  let i = str.length;\n  let hash1 = 5381;\n  let hash2 = 52711;\n\n  while (i--) {\n    const char = str.charCodeAt(i);\n    hash1 = (hash1 * 33) ^ char;\n    hash2 = (hash2 * 33) ^ char;\n  }\n\n  return (hash1 >>> 0) * 4096 + (hash2 >>> 0);\n}\n\nfunction shouldGenerateSourceMap() {\n  if (isRelease()) {\n    return false;\n  }\n\n  if (process.env.REANIMATED_PLUGIN_TESTS === 'jest') {\n    // We want to detect this, so we can disable source maps (because they break\n    // snapshot tests with jest).\n    return false;\n  }\n\n  return true;\n}\n\nfunction buildWorkletString(\n  fun: BabelTypesFile,\n  closureVariables: Array<Identifier>,\n  name: string,\n  inputMap: BabelFileResult['map']\n): Array<string | null | undefined> {\n  function prependClosureVariablesIfNecessary() {\n    const closureDeclaration = variableDeclaration('const', [\n      variableDeclarator(\n        objectPattern(\n          closureVariables.map((variable) =>\n            objectProperty(\n              identifier(variable.name),\n              identifier(variable.name),\n              false,\n              true\n            )\n          )\n        ),\n        memberExpression(thisExpression(), identifier('_closure'))\n      ),\n    ]);\n\n    function prependClosure(\n      path: NodePath<\n        | FunctionDeclaration\n        | FunctionExpression\n        | ArrowFunctionExpression\n        | ObjectMethod\n      >\n    ) {\n      if (closureVariables.length === 0 || path.parent.type !== 'Program') {\n        return;\n      }\n\n      if (!isExpression(path.node.body)) {\n        path.node.body.body.unshift(closureDeclaration);\n      }\n    }\n\n    function prependRecursiveDeclaration(\n      path: NodePath<\n        | FunctionDeclaration\n        | FunctionExpression\n        | ArrowFunctionExpression\n        | ObjectMethod\n      >\n    ) {\n      if (\n        path.parent.type === 'Program' &&\n        !isArrowFunctionExpression(path.node) &&\n        !isObjectMethod(path.node) &&\n        path.node.id &&\n        path.scope.parent\n      ) {\n        const hasRecursiveCalls =\n          path.scope.parent.bindings[path.node.id.name]?.references > 0;\n        if (hasRecursiveCalls) {\n          path.node.body.body.unshift(\n            variableDeclaration('const', [\n              variableDeclarator(\n                identifier(path.node.id.name),\n                memberExpression(thisExpression(), identifier('_recur'))\n              ),\n            ])\n          );\n        }\n      }\n    }\n\n    return {\n      visitor: {\n        'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression|ObjectMethod':\n          (\n            path: NodePath<\n              | FunctionDeclaration\n              | FunctionExpression\n              | ArrowFunctionExpression\n              | ObjectMethod\n            >\n          ) => {\n            prependClosure(path);\n            prependRecursiveDeclaration(path);\n          },\n      },\n    };\n  }\n\n  const draftExpression = (fun.program.body.find((obj) =>\n    isFunctionDeclaration(obj)\n  ) ||\n    fun.program.body.find((obj) => isExpressionStatement(obj)) ||\n    undefined) as FunctionDeclaration | ExpressionStatement | undefined;\n\n  assertIsDefined(draftExpression);\n\n  const expression = isFunctionDeclaration(draftExpression)\n    ? draftExpression\n    : draftExpression.expression;\n\n  if (!('params' in expression && isBlockStatement(expression.body))) {\n    throw new Error(\n      \"'expression' doesn't have property 'params' or 'expression.body' is not a BlockStatmenent\\n'\"\n    );\n  }\n\n  const workletFunction = functionExpression(\n    identifier(name),\n    expression.params,\n    expression.body\n  );\n\n  const code = generate(workletFunction).code;\n\n  assertIsDefined(inputMap);\n\n  const includeSourceMap = shouldGenerateSourceMap();\n\n  if (includeSourceMap) {\n    // Clear contents array (should be empty anyways)\n    inputMap.sourcesContent = [];\n    // Include source contents in source map, because Flipper/iframe is not\n    // allowed to read files from disk.\n    for (const sourceFile of inputMap.sources) {\n      inputMap.sourcesContent.push(\n        fs.readFileSync(sourceFile).toString('utf-8')\n      );\n    }\n  }\n\n  const transformed = transformSync(code, {\n    plugins: [prependClosureVariablesIfNecessary()],\n    compact: !includeSourceMap,\n    sourceMaps: includeSourceMap,\n    inputSourceMap: inputMap,\n    ast: false,\n    babelrc: false,\n    configFile: false,\n    comments: false,\n  });\n\n  assertIsDefined(transformed);\n\n  let sourceMap;\n  if (includeSourceMap) {\n    sourceMap = convertSourceMap.fromObject(transformed.map).toObject();\n    // sourcesContent field contains a full source code of the file which contains the worklet\n    // and is not needed by the source map interpreter in order to symbolicate a stack trace.\n    // Therefore, we remove it to reduce the bandwith and avoid sending it potentially multiple times\n    // in files that contain multiple worklets. Along with sourcesContent.\n    delete sourceMap.sourcesContent;\n  }\n\n  return [transformed.code, JSON.stringify(sourceMap)];\n}\n\nfunction makeWorkletName(\n  fun: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ObjectMethod\n    | ArrowFunctionExpression\n  >\n) {\n  if (isObjectMethod(fun.node) && 'name' in fun.node.key) {\n    return fun.node.key.name;\n  }\n  if (isFunctionDeclaration(fun.node) && fun.node.id) {\n    return fun.node.id.name;\n  }\n  if (isFunctionExpression(fun.node) && isIdentifier(fun.node.id)) {\n    return fun.node.id.name;\n  }\n  return 'anonymous'; // fallback for ArrowFunctionExpression and unnamed FunctionExpression\n}\n\nexport function makeWorklet(\n  fun: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ObjectMethod\n    | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n): FunctionExpression {\n  // Returns a new FunctionExpression which is a workletized version of provided\n  // FunctionDeclaration, FunctionExpression, ArrowFunctionExpression or ObjectMethod.\n\n  const functionName = makeWorkletName(fun);\n\n  const closure = new Map<string, Identifier>();\n\n  // remove 'worklet'; directive before generating string\n  fun.traverse({\n    DirectiveLiteral(path) {\n      if (path.node.value === 'worklet' && path.getFunctionParent() === fun) {\n        path.parentPath.remove();\n      }\n    },\n  });\n\n  // We use copy because some of the plugins don't update bindings and\n  // some even break them\n  assertIsDefined(state.file.opts.filename);\n\n  const codeObject = generate(fun.node, {\n    sourceMaps: true,\n    sourceFileName: state.file.opts.filename,\n  });\n\n  // We need to add a newline at the end, because there could potentially be a\n  // comment after the function that gets included here, and then the closing\n  // bracket would become part of the comment thus resulting in an error, since\n  // there is a missing closing bracket.\n  const code =\n    '(' + (isObjectMethod(fun) ? 'function ' : '') + codeObject.code + '\\n)';\n\n  const transformed = transformSync(code, {\n    filename: state.file.opts.filename,\n    presets: ['@babel/preset-typescript'],\n    plugins: [\n      '@babel/plugin-transform-shorthand-properties',\n      '@babel/plugin-transform-arrow-functions',\n      '@babel/plugin-proposal-optional-chaining',\n      '@babel/plugin-proposal-nullish-coalescing-operator',\n      ['@babel/plugin-transform-template-literals', { loose: true }],\n    ],\n    ast: true,\n    babelrc: false,\n    configFile: false,\n    inputSourceMap: codeObject.map,\n  });\n\n  assertIsDefined(transformed);\n  assertIsDefined(transformed.ast);\n\n  traverse(transformed.ast, {\n    Identifier(path) {\n      if (!path.isReferencedIdentifier()) return;\n      const name = path.node.name;\n      if (\n        globals.has(name) ||\n        (!isArrowFunctionExpression(fun.node) &&\n          !isObjectMethod(fun.node) &&\n          fun.node.id &&\n          fun.node.id.name === name)\n      ) {\n        return;\n      }\n\n      const parentNode = path.parent;\n\n      if (\n        parentNode.type === 'MemberExpression' &&\n        parentNode.property === path.node &&\n        !parentNode.computed\n      ) {\n        return;\n      }\n\n      if (\n        parentNode.type === 'ObjectProperty' &&\n        path.parentPath.parent.type === 'ObjectExpression' &&\n        path.node !== parentNode.value\n      ) {\n        return;\n      }\n\n      let currentScope = path.scope;\n\n      while (currentScope != null) {\n        if (currentScope.bindings[name] != null) {\n          return;\n        }\n        currentScope = currentScope.parent;\n      }\n      closure.set(name, path.node);\n    },\n  });\n\n  const variables = Array.from(closure.values());\n\n  const privateFunctionId = identifier('_f');\n  const clone = cloneNode(fun.node);\n  const funExpression = isBlockStatement(clone.body)\n    ? functionExpression(null, clone.params, clone.body)\n    : clone;\n\n  const [funString, sourceMapString] = buildWorkletString(\n    transformed.ast,\n    variables,\n    functionName,\n    transformed.map\n  );\n  assertIsDefined(funString);\n  const workletHash = hash(funString);\n\n  let location = state.file.opts.filename;\n  if (state.opts.relativeSourceLocation) {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const path = require('path');\n    location = path.relative(state.cwd, location);\n  }\n\n  let lineOffset = 1;\n  if (closure.size > 0) {\n    // When worklet captures some variables, we append closure destructing at\n    // the beginning of the function body. This effectively results in line\n    // numbers shifting by the number of captured variables (size of the\n    // closure) + 2 (for the opening and closing brackets of the destruct\n    // statement)\n    lineOffset -= closure.size + 2;\n  }\n\n  const pathForStringDefinitions = fun.parentPath.isProgram()\n    ? fun\n    : (fun.findParent(\n        (path) => (path.parentPath as NodePath<BabelNode>).isProgram() // lack of this 'as ...' causes typescript error on Windows CI build\n      ) as NodePath<BabelNode>); // lack of this 'as ...' this causes typescript error on Windows CI build\n\n  const initDataId = (\n    pathForStringDefinitions.parentPath as NodePath<BabelNode>\n  ).scope // lack of this 'as ...' this causes typescript error on Windows CI build\n    .generateUidIdentifier(`worklet_${workletHash}_init_data`);\n\n  const initDataObjectExpression = objectExpression([\n    objectProperty(identifier('code'), stringLiteral(funString)),\n    objectProperty(identifier('location'), stringLiteral(location)),\n  ]);\n\n  if (sourceMapString) {\n    initDataObjectExpression.properties.push(\n      objectProperty(identifier('sourceMap'), stringLiteral(sourceMapString))\n    );\n  }\n\n  pathForStringDefinitions.insertBefore(\n    variableDeclaration('const', [\n      variableDeclarator(initDataId, initDataObjectExpression),\n    ])\n  );\n\n  if (isFunctionDeclaration(funExpression) || isObjectMethod(funExpression)) {\n    throw new Error(\n      \"'funExpression' is either FunctionDeclaration or ObjectMethod and cannot be used in variableDeclaration\\n\"\n    );\n  }\n\n  const statements: Array<\n    VariableDeclaration | ExpressionStatement | ReturnStatement\n  > = [\n    variableDeclaration('const', [\n      variableDeclarator(privateFunctionId, funExpression),\n    ]),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(privateFunctionId, identifier('_closure'), false),\n        objectExpression(\n          variables.map((variable) =>\n            objectProperty(identifier(variable.name), variable, false, true)\n          )\n        )\n      )\n    ),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(privateFunctionId, identifier('__initData'), false),\n        initDataId\n      )\n    ),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(privateFunctionId, identifier('__workletHash'), false),\n        numericLiteral(workletHash)\n      )\n    ),\n  ];\n\n  if (!isRelease()) {\n    statements.unshift(\n      variableDeclaration('const', [\n        variableDeclarator(\n          identifier('_e'),\n          arrayExpression([\n            newExpression(\n              memberExpression(identifier('global'), identifier('Error')),\n              []\n            ),\n            numericLiteral(lineOffset),\n            numericLiteral(-27), // the placement of opening bracket after Exception in line that defined '_e' variable\n          ])\n        ),\n      ])\n    );\n    statements.push(\n      expressionStatement(\n        assignmentExpression(\n          '=',\n          memberExpression(\n            privateFunctionId,\n            identifier('__stackDetails'),\n            false\n          ),\n          identifier('_e')\n        )\n      )\n    );\n  }\n\n  statements.push(returnStatement(privateFunctionId));\n\n  const newFun = functionExpression(\n    // !isArrowFunctionExpression(fun.node) ? fun.node.id : undefined, // [TO DO] --- this never worked\n    undefined,\n    [],\n    blockStatement(statements)\n  );\n\n  return newFun;\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  ObjectMethod,\n  identifier,\n  isIdentifier,\n  isFunctionParent,\n  objectProperty,\n  callExpression,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { makeWorklet } from './makeWorklet';\n\nexport function processWorkletObjectMethod(\n  path: NodePath<ObjectMethod>,\n  state: ReanimatedPluginPass\n) {\n  // Replaces ObjectMethod with a workletized version of itself.\n\n  if (!isFunctionParent(path)) return;\n\n  const newFun = makeWorklet(path, state);\n\n  const replacement = objectProperty(\n    identifier(isIdentifier(path.node.key) ? path.node.key.name : ''),\n    callExpression(newFun, [])\n  );\n\n  path.replaceWith(replacement);\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  callExpression,\n  isScopable,\n  isExportNamedDeclaration,\n  isArrowFunctionExpression,\n  variableDeclaration,\n  isFunctionParent,\n  variableDeclarator,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { makeWorklet } from './makeWorklet';\n\nexport function processIfWorkletFunction(\n  fun: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n) {\n  // Replaces FunctionDeclaration, FunctionExpression or ArrowFunctionExpression\n  // with a workletized version of itself.\n\n  if (!isFunctionParent(fun)) {\n    return;\n  }\n\n  const newFun = makeWorklet(fun, state);\n\n  const replacement = callExpression(newFun, []);\n\n  // we check if function needs to be assigned to variable declaration.\n  // This is needed if function definition directly in a scope. Some other ways\n  // where function definition can be used is for example with variable declaration:\n  // const ggg = function foo() { }\n  // ^ in such a case we don't need to define variable for the function\n  const needDeclaration =\n    isScopable(fun.parent) || isExportNamedDeclaration(fun.parent);\n  fun.replaceWith(\n    !isArrowFunctionExpression(fun.node) && fun.node.id && needDeclaration\n      ? variableDeclaration('const', [\n          variableDeclarator(fun.node.id, replacement),\n        ])\n      : replacement\n  );\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  CallExpression,\n  isSequenceExpression,\n  isObjectExpression,\n  ObjectMethod,\n  ObjectProperty,\n  isObjectMethod,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { processWorkletObjectMethod } from './processWorkletObjectMethod';\nimport { processIfWorkletFunction } from './processIfWorkletFunction';\n\nconst functionArgsToWorkletize = new Map([\n  ['useFrameCallback', [0]],\n  ['useAnimatedStyle', [0]],\n  ['useAnimatedProps', [0]],\n  ['createAnimatedPropAdapter', [0]],\n  ['useDerivedValue', [0]],\n  ['useAnimatedScrollHandler', [0]],\n  ['useAnimatedReaction', [0, 1]],\n  ['useWorkletCallback', [0]],\n  // animations' callbacks\n  ['withTiming', [2]],\n  ['withSpring', [2]],\n  ['withDecay', [1]],\n  ['withRepeat', [3]],\n]);\n\nconst objectHooks = new Set([\n  'useAnimatedGestureHandler',\n  'useAnimatedScrollHandler',\n]);\n\nexport function processForCalleesWorklets(\n  path: NodePath<CallExpression>,\n  state: ReanimatedPluginPass\n) {\n  const callee = isSequenceExpression(path.node.callee)\n    ? path.node.callee.expressions[path.node.callee.expressions.length - 1]\n    : path.node.callee;\n\n  let name = '';\n  if ('name' in callee) {\n    name = callee.name;\n  } else if ('property' in callee && 'name' in callee.property) {\n    name = callee.property.name;\n  }\n  // else name = 'anonymous'; --- might add it in the future [TO DO]\n\n  if (\n    objectHooks.has(name) &&\n    isObjectExpression(\n      (path.get('arguments.0') as NodePath<CallExpression['arguments'][number]>)\n        .node\n    )\n  ) {\n    const properties = path.get('arguments.0.properties') as Array<\n      NodePath<ObjectMethod | ObjectProperty>\n    >;\n    for (const property of properties) {\n      if (isObjectMethod(property.node)) {\n        processWorkletObjectMethod(property as NodePath<ObjectMethod>, state);\n      } else {\n        const value = property.get('value') as NodePath<\n          ObjectProperty['value']\n        >;\n        processIfWorkletFunction(\n          value as NodePath<\n            FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n          >,\n          state\n        ); // temporarily given 3 types [TO DO]\n      }\n    }\n  } else {\n    const indexes = functionArgsToWorkletize.get(name);\n    if (Array.isArray(indexes)) {\n      indexes.forEach((index) => {\n        processIfWorkletFunction(\n          path.get(`arguments.${index}`) as NodePath<\n            FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n          >,\n          state\n        ); // temporarily given 3 types [TO DO]\n      });\n    }\n  }\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  isBlockStatement,\n  isDirectiveLiteral,\n} from '@babel/types';\nimport { processIfWorkletFunction } from './processIfWorkletFunction';\nimport { ReanimatedPluginPass } from './types';\n\nexport function processIfWorkletNode(\n  fun: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n) {\n  fun.traverse({\n    DirectiveLiteral(path) {\n      const value = path.node.value;\n      if (\n        value === 'worklet' &&\n        path.getFunctionParent() === fun &&\n        isBlockStatement(fun.node.body)\n      ) {\n        // make sure \"worklet\" is listed among directives for the fun\n        // this is necessary as because of some bug, babel will attempt to\n        // process replaced function if it is nested inside another function\n        const directives = fun.node.body.directives;\n        if (\n          directives &&\n          directives.length > 0 &&\n          directives.some(\n            (directive) =>\n              isDirectiveLiteral(directive.value) &&\n              directive.value.value === 'worklet'\n          )\n        ) {\n          processIfWorkletFunction(fun, state);\n        }\n      }\n    },\n  });\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  isIdentifier,\n  isCallExpression,\n  Expression,\n  isMemberExpression,\n  isExpression,\n} from '@babel/types';\nimport { processIfWorkletFunction } from './processIfWorkletFunction';\nimport { ReanimatedPluginPass } from './types';\n\nconst gestureHandlerGestureObjects = new Set([\n  // from https://github.com/software-mansion/react-native-gesture-handler/blob/new-api/src/handlers/gestures/gestureObjects.ts\n  'Tap',\n  'Pan',\n  'Pinch',\n  'Rotation',\n  'Fling',\n  'LongPress',\n  'ForceTouch',\n  'Native',\n  'Manual',\n  'Race',\n  'Simultaneous',\n  'Exclusive',\n]);\n\nconst gestureHandlerBuilderMethods = new Set([\n  'onBegin',\n  'onStart',\n  'onEnd',\n  'onFinalize',\n  'onUpdate',\n  'onChange',\n  'onTouchesDown',\n  'onTouchesMove',\n  'onTouchesUp',\n  'onTouchesCancelled',\n]);\n\nexport function processIfGestureHandlerEventCallbackFunctionNode(\n  fun: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n) {\n  // Auto-workletizes React Native Gesture Handler callback functions.\n  // Detects `Gesture.Tap().onEnd(<fun>)` or similar, but skips `something.onEnd(<fun>)`.\n  // Supports method chaining as well, e.g. `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`.\n\n  // Example #1: `Gesture.Tap().onEnd(<fun>)`\n  /*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: Identifier('Gesture')\n          property: Identifier('Tap')\n        )\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun]\n  )\n  */\n\n  // Example #2: `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`\n  /*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: CallExpression(\n            callee: MemberExpression(\n              object: CallExpression(\n                callee: MemberExpression(\n                  object: Identifier('Gesture')\n                  property: Identifier('Tap')\n                )\n              )\n              property: Identifier('onStart')\n            )\n            arguments: [fun1]\n          )\n          property: Identifier('onUpdate')\n        )\n        arguments: [fun2]\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun3]\n  )\n  */\n\n  if (\n    isCallExpression(fun.parent) &&\n    isExpression(fun.parent.callee) &&\n    isGestureObjectEventCallbackMethod(fun.parent.callee)\n  ) {\n    processIfWorkletFunction(fun, state);\n  }\n}\n\nfunction isGestureObjectEventCallbackMethod(node: Expression) {\n  // Checks if node matches the pattern `Gesture.Foo()[*].onBar`\n  // where `[*]` represents any number of method calls.\n  return (\n    isMemberExpression(node) &&\n    isIdentifier(node.property) &&\n    gestureHandlerBuilderMethods.has(node.property.name) &&\n    containsGestureObject(node.object)\n  );\n}\n\nfunction containsGestureObject(node: Expression) {\n  // Checks if node matches the pattern `Gesture.Foo()[*]`\n  // where `[*]` represents any number of chained method calls, like `.something(42)`.\n\n  // direct call\n  if (isGestureObject(node)) {\n    return true;\n  }\n\n  // method chaining\n  if (\n    isCallExpression(node) &&\n    isMemberExpression(node.callee) &&\n    containsGestureObject(node.callee.object)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isGestureObject(node: Expression) {\n  // Checks if node matches `Gesture.Tap()` or similar.\n  /*\n  node: CallExpression(\n    callee: MemberExpression(\n      object: Identifier('Gesture')\n      property: Identifier('Tap')\n    )\n  )\n  */\n  return (\n    isCallExpression(node) &&\n    isMemberExpression(node.callee) &&\n    isIdentifier(node.callee.object) &&\n    node.callee.object.name === 'Gesture' &&\n    isIdentifier(node.callee.property) &&\n    gestureHandlerGestureObjects.has(node.callee.property.name)\n  );\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  MemberExpression,\n  callExpression,\n  arrowFunctionExpression,\n  isMemberExpression,\n  isArrayExpression,\n  isObjectExpression,\n  ArrayExpression,\n  ObjectExpression,\n  isObjectProperty,\n  JSXAttribute,\n  isJSXExpressionContainer,\n  Expression,\n  identifier,\n  stringLiteral,\n  expressionStatement,\n  memberExpression,\n  returnStatement,\n  blockStatement,\n  ObjectProperty,\n  isIdentifier,\n} from '@babel/types';\nimport { isRelease } from './utils';\nimport { ReanimatedPluginPass } from './types';\n\nfunction generateInlineStylesWarning(path: NodePath<MemberExpression>) {\n  // replaces `sharedvalue.value` with `(()=>{console.warn(require('react-native-reanimated').getUseOfValueInStyleWarning());return sharedvalue.value;})()`\n  return callExpression(\n    arrowFunctionExpression(\n      [],\n      blockStatement([\n        expressionStatement(\n          callExpression(\n            memberExpression(identifier('console'), identifier('warn')),\n            [\n              callExpression(\n                memberExpression(\n                  callExpression(identifier('require'), [\n                    stringLiteral('react-native-reanimated'),\n                  ]),\n                  identifier('getUseOfValueInStyleWarning')\n                ),\n                []\n              ),\n            ]\n          )\n        ),\n        returnStatement(path.node),\n      ])\n    ),\n    []\n  );\n}\n\nfunction processPropertyValueForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n) {\n  // if it's something like object.value then raise a warning\n  if (isMemberExpression(path.node) && isIdentifier(path.node.property)) {\n    if (path.node.property.name === 'value') {\n      path.replaceWith(\n        generateInlineStylesWarning(path as NodePath<MemberExpression>)\n      );\n    }\n  }\n}\n\nfunction processTransformPropertyForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n) {\n  if (isArrayExpression(path.node)) {\n    const elements = path.get('elements') as Array<\n      NodePath<ArrayExpression['elements'][number]>\n    >;\n    for (const element of elements) {\n      if (isObjectExpression(element.node)) {\n        processStyleObjectForInlineStylesWarning(\n          element as NodePath<ObjectExpression>\n        ); // why is it not inferred? [TO DO]\n      }\n    }\n  }\n}\n\nfunction processStyleObjectForInlineStylesWarning(\n  path: NodePath<ObjectExpression>\n) {\n  const properties = path.get('properties') as Array<\n    NodePath<ObjectExpression['properties'][number]>\n  >;\n  for (const property of properties) {\n    if (!isObjectProperty(property.node)) continue;\n    const value = property.get('value') as NodePath<ObjectProperty['value']>;\n    if (isObjectProperty(property)) {\n      if (\n        isIdentifier(property.node.key) &&\n        property.node.key.name === 'transform'\n      ) {\n        processTransformPropertyForInlineStylesWarning(value);\n      } else {\n        processPropertyValueForInlineStylesWarning(value);\n      }\n    }\n  }\n}\n\nexport function processInlineStylesWarning(\n  path: NodePath<JSXAttribute>,\n  state: ReanimatedPluginPass\n) {\n  if (isRelease()) return;\n  if (state.opts.disableInlineStylesWarning) return;\n  if (path.node.name.name !== 'style') return;\n  if (!isJSXExpressionContainer(path.node.value)) return;\n\n  const expression = path\n    .get('value')\n    .get('expression') as NodePath<Expression>;\n  // style={[{...}, {...}]}\n  if (isArrayExpression(expression.node)) {\n    const elements = expression.get('elements') as Array<\n      NodePath<ArrayExpression['elements'][number]>\n    >;\n    for (const element of elements) {\n      if (isObjectExpression(element.node)) {\n        processStyleObjectForInlineStylesWarning(\n          element as NodePath<ObjectExpression>\n        ); // why is it not inferred? [TO DO]\n      }\n    }\n  }\n  // style={{...}}\n  else if (isObjectExpression(expression.node)) {\n    processStyleObjectForInlineStylesWarning(\n      expression as NodePath<ObjectExpression>\n    ); // why is it not inferred? [TO DO]\n  }\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  DirectiveLiteral,\n  expressionStatement,\n  assignmentExpression,\n  memberExpression,\n  identifier,\n  stringLiteral,\n  FunctionDeclaration,\n} from '@babel/types';\n\nexport function injectVersion(path: NodePath<DirectiveLiteral>) {\n  // We want to inject plugin's version only once,\n  // hence we have a Directive Literal line in Reanimated code.\n  // See src/reanimated2/platform-specific/checkPluginVersion.ts\n  // to see the details of this implementation.\n  if (path.node.value !== 'inject Reanimated Babel plugin version') {\n    return;\n  }\n  const injectedName = '_REANIMATED_VERSION_BABEL_PLUGIN';\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const versionString = require('../../package.json').version;\n  const pluginVersionNode = expressionStatement(\n    assignmentExpression(\n      '=',\n      memberExpression(identifier('global'), identifier(injectedName)),\n      stringLiteral(versionString)\n    )\n  );\n\n  const functionParent = (\n    path.getFunctionParent() as NodePath<FunctionDeclaration>\n  ).node;\n  // DirectiveLiteral is in property of its function parent 'directives' hence we cannot just replace it.\n  functionParent.body.directives = [];\n  functionParent.body.body.unshift(pluginVersionNode);\n}\n", "import { PluginItem, NodePath } from '@babel/core';\nimport { globals } from './commonObjects';\nimport {\n  CallExpression,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  DirectiveLiteral,\n} from '@babel/types';\nimport { processForCalleesWorklets } from './processForCalleesWorklets';\nimport { ReanimatedPluginPass } from './types';\nimport { processIfWorkletNode } from './processIfWorkletNode';\nimport { processIfGestureHandlerEventCallbackFunctionNode } from './processIfGestureHandlerEventCallbackFunctionNode';\nimport { processInlineStylesWarning } from './processInlineStylesWarning';\nimport { injectVersion } from './injectVersion';\n\nmodule.exports = function (): PluginItem {\n  return {\n    pre() {\n      // allows adding custom globals such as host-functions\n      if (this.opts != null && Array.isArray(this.opts.globals)) {\n        this.opts.globals.forEach((name: string) => {\n          globals.add(name);\n        });\n      }\n    },\n    visitor: {\n      DirectiveLiteral: {\n        enter(path: NodePath<DirectiveLiteral>) {\n          injectVersion(path);\n        },\n      },\n      CallExpression: {\n        enter(path: NodePath<CallExpression>, state: ReanimatedPluginPass) {\n          processForCalleesWorklets(path, state);\n        },\n      },\n      'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression': {\n        enter(\n          path: NodePath<\n            FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n          >,\n          state: ReanimatedPluginPass\n        ) {\n          processIfWorkletNode(path, state);\n          processIfGestureHandlerEventCallbackFunctionNode(path, state);\n        },\n      },\n      JSXAttribute: {\n        enter(path, state) {\n          processInlineStylesWarning(path, state);\n        },\n      },\n    },\n  };\n};\n"],
  "mappings": "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",
  "names": ["exports", "exports", "exports", "commonObjects_1", "exports", "exports", "exports", "exports", "exports", "exports", "exports", "exports"]
=======
  "sources": ["../src/commonObjects.ts", "../src/utils.ts", "../src/makeWorklet.ts", "../src/processWorkletObjectMethod.ts", "../src/processWorkletFunction.ts", "../src/processWorklets.ts", "../src/processIfWorkletNode.ts", "../src/processIfGestureHandlerEventCallbackFunctionNode.ts", "../src/processInlineStylesWarning.ts", "../src/injectVersion.ts", "../src/plugin.ts"],
  "sourcesContent": ["export const globals = new Set([\n  'this',\n  'console',\n  'performance',\n  'Date',\n  'Array',\n  'ArrayBuffer',\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'HermesInternal',\n  'JSON',\n  'Math',\n  'Number',\n  'Object',\n  'String',\n  'Symbol',\n  'undefined',\n  'null',\n  'UIManager',\n  'requestAnimationFrame',\n  'setImmediate',\n  'queueMicrotask',\n  '_WORKLET',\n  'arguments',\n  'Boolean',\n  'parseInt',\n  'parseFloat',\n  'Map',\n  'WeakMap',\n  'WeakRef',\n  'Set',\n  '_log',\n  '_scheduleOnJS',\n  '_makeShareableClone',\n  '_updateDataSynchronously',\n  'eval',\n  '_updatePropsPaper',\n  '_updatePropsFabric',\n  '_removeShadowNodeFromRegistry',\n  'RegExp',\n  'Error',\n  'ErrorUtils',\n  'global',\n  '_measure',\n  '_scrollTo',\n  '_dispatchCommand',\n  '_setGestureState',\n  '_getCurrentTime',\n  'isNaN',\n  'LayoutAnimationRepository',\n  '_notifyAboutProgress',\n  '_notifyAboutEnd',\n]);\n", "export function isRelease() {\n  return (\n    process.env.BABEL_ENV &&\n    ['production', 'release'].includes(process.env.BABEL_ENV)\n  );\n}\n", "import {\n  BabelFileResult,\n  NodePath,\n  transformSync,\n  traverse,\n  Node as BabelNode,\n} from '@babel/core';\nimport generate from '@babel/generator';\nimport {\n  ObjectMethod,\n  isObjectMethod,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  identifier,\n  Identifier,\n  objectProperty,\n  isArrowFunctionExpression,\n  variableDeclaration,\n  variableDeclarator,\n  cloneNode,\n  isBlockStatement,\n  functionExpression,\n  objectExpression,\n  stringLiteral,\n  isFunctionDeclaration,\n  VariableDeclaration,\n  ExpressionStatement,\n  ReturnStatement,\n  expressionStatement,\n  assignmentExpression,\n  memberExpression,\n  numericLiteral,\n  arrayExpression,\n  newExpression,\n  returnStatement,\n  blockStatement,\n  isFunctionExpression,\n  isIdentifier,\n  File as BabelTypesFile,\n  objectPattern,\n  thisExpression,\n  isExpression,\n  isExpressionStatement,\n} from '@babel/types';\nimport * as fs from 'fs';\nimport * as convertSourceMap from 'convert-source-map';\nimport { ReanimatedPluginPass } from './types';\nimport { isRelease } from './utils';\nimport { globals } from './commonObjects';\nimport { strict as assert } from 'assert';\n\nfunction hash(str: string) {\n  let i = str.length;\n  let hash1 = 5381;\n  let hash2 = 52711;\n\n  while (i--) {\n    const char = str.charCodeAt(i);\n    // eslint-disable-next-line no-bitwise\n    hash1 = (hash1 * 33) ^ char;\n    // eslint-disable-next-line no-bitwise\n    hash2 = (hash2 * 33) ^ char;\n  }\n\n  // eslint-disable-next-line no-bitwise\n  return (hash1 >>> 0) * 4096 + (hash2 >>> 0);\n}\n\nfunction shouldGenerateSourceMap() {\n  if (isRelease()) {\n    return false;\n  }\n\n  if (process.env.REANIMATED_PLUGIN_TESTS === 'jest') {\n    // We want to detect this, so we can disable source maps (because they break\n    // snapshot tests with jest).\n    return false;\n  }\n\n  return true;\n}\n\nfunction buildWorkletString(\n  fun: BabelTypesFile,\n  closureVariables: Array<Identifier>,\n  name: string,\n  inputMap: BabelFileResult['map']\n): Array<string | null | undefined> {\n  function prependClosureVariablesIfNecessary() {\n    const closureDeclaration = variableDeclaration('const', [\n      variableDeclarator(\n        objectPattern(\n          closureVariables.map((variable) =>\n            objectProperty(\n              identifier(variable.name),\n              identifier(variable.name),\n              false,\n              true\n            )\n          )\n        ),\n        memberExpression(thisExpression(), identifier('_closure'))\n      ),\n    ]);\n\n    function prependClosure(\n      path: NodePath<\n        | FunctionDeclaration\n        | FunctionExpression\n        | ArrowFunctionExpression\n        | ObjectMethod\n      >\n    ) {\n      if (closureVariables.length === 0 || path.parent.type !== 'Program') {\n        return;\n      }\n\n      if (!isExpression(path.node.body)) {\n        path.node.body.body.unshift(closureDeclaration);\n      }\n    }\n\n    function prependRecursiveDeclaration(\n      path: NodePath<\n        | FunctionDeclaration\n        | FunctionExpression\n        | ArrowFunctionExpression\n        | ObjectMethod\n      >\n    ) {\n      if (\n        path.parent.type === 'Program' &&\n        !isArrowFunctionExpression(path.node) &&\n        !isObjectMethod(path.node) &&\n        path.node.id &&\n        path.scope.parent\n      ) {\n        const hasRecursiveCalls =\n          path.scope.parent.bindings[path.node.id.name]?.references > 0;\n        if (hasRecursiveCalls) {\n          path.node.body.body.unshift(\n            variableDeclaration('const', [\n              variableDeclarator(\n                identifier(path.node.id.name),\n                memberExpression(thisExpression(), identifier('_recur'))\n              ),\n            ])\n          );\n        }\n      }\n    }\n\n    return {\n      visitor: {\n        'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression|ObjectMethod':\n          (\n            path: NodePath<\n              | FunctionDeclaration\n              | FunctionExpression\n              | ArrowFunctionExpression\n              | ObjectMethod\n            >\n          ) => {\n            prependClosure(path);\n            prependRecursiveDeclaration(path);\n          },\n      },\n    };\n  }\n\n  const draftExpression = (fun.program.body.find((obj) =>\n    isFunctionDeclaration(obj)\n  ) ||\n    fun.program.body.find((obj) => isExpressionStatement(obj)) ||\n    undefined) as FunctionDeclaration | ExpressionStatement | undefined;\n\n  assert(draftExpression, \"'draftExpression' is undefined\");\n\n  const expression = isFunctionDeclaration(draftExpression)\n    ? draftExpression\n    : draftExpression.expression;\n\n  assert(\n    'params' in expression,\n    \"'params' property is undefined in 'expression'\"\n  );\n  assert(\n    isBlockStatement(expression.body),\n    \"'expression.body' is not a 'blockStatement'\"\n  );\n\n  const workletFunction = functionExpression(\n    identifier(name),\n    expression.params,\n    expression.body\n  );\n\n  const code = generate(workletFunction).code;\n\n  assert(inputMap, \"'inputMap' is undefined\");\n\n  const includeSourceMap = shouldGenerateSourceMap();\n\n  if (includeSourceMap) {\n    // Clear contents array (should be empty anyways)\n    inputMap.sourcesContent = [];\n    // Include source contents in source map, because Flipper/iframe is not\n    // allowed to read files from disk.\n    for (const sourceFile of inputMap.sources) {\n      inputMap.sourcesContent.push(\n        fs.readFileSync(sourceFile).toString('utf-8')\n      );\n    }\n  }\n\n  const transformed = transformSync(code, {\n    plugins: [prependClosureVariablesIfNecessary()],\n    compact: !includeSourceMap,\n    sourceMaps: includeSourceMap,\n    inputSourceMap: inputMap,\n    ast: false,\n    babelrc: false,\n    configFile: false,\n    comments: false,\n  });\n\n  assert(transformed, \"'transformed' is undefined\");\n\n  let sourceMap;\n  if (includeSourceMap) {\n    sourceMap = convertSourceMap.fromObject(transformed.map).toObject();\n    // sourcesContent field contains a full source code of the file which contains the worklet\n    // and is not needed by the source map interpreter in order to symbolicate a stack trace.\n    // Therefore, we remove it to reduce the bandwith and avoid sending it potentially multiple times\n    // in files that contain multiple worklets. Along with sourcesContent.\n    delete sourceMap.sourcesContent;\n  }\n\n  return [transformed.code, JSON.stringify(sourceMap)];\n}\n\nfunction makeWorkletName(\n  fun: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ObjectMethod\n    | ArrowFunctionExpression\n  >\n) {\n  if (isObjectMethod(fun.node) && 'name' in fun.node.key) {\n    return fun.node.key.name;\n  }\n  if (isFunctionDeclaration(fun.node) && fun.node.id) {\n    return fun.node.id.name;\n  }\n  if (isFunctionExpression(fun.node) && isIdentifier(fun.node.id)) {\n    return fun.node.id.name;\n  }\n  return 'anonymous'; // fallback for ArrowFunctionExpression and unnamed FunctionExpression\n}\n\nexport function makeWorklet(\n  fun: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ObjectMethod\n    | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n): FunctionExpression {\n  // Returns a new FunctionExpression which is a workletized version of provided\n  // FunctionDeclaration, FunctionExpression, ArrowFunctionExpression or ObjectMethod.\n\n  const functionName = makeWorkletName(fun);\n\n  const closure = new Map<string, Identifier>();\n\n  // remove 'worklet'; directive before generating string\n  fun.traverse({\n    DirectiveLiteral(path) {\n      if (path.node.value === 'worklet' && path.getFunctionParent() === fun) {\n        path.parentPath.remove();\n      }\n    },\n  });\n\n  // We use copy because some of the plugins don't update bindings and\n  // some even break them\n  assert(state.file.opts.filename, \"'state.file.opts.filename' is undefined\");\n\n  const codeObject = generate(fun.node, {\n    sourceMaps: true,\n    sourceFileName: state.file.opts.filename,\n  });\n\n  // We need to add a newline at the end, because there could potentially be a\n  // comment after the function that gets included here, and then the closing\n  // bracket would become part of the comment thus resulting in an error, since\n  // there is a missing closing bracket.\n  const code =\n    '(' + (isObjectMethod(fun) ? 'function ' : '') + codeObject.code + '\\n)';\n\n  const transformed = transformSync(code, {\n    filename: state.file.opts.filename,\n    presets: ['@babel/preset-typescript'],\n    plugins: [\n      '@babel/plugin-transform-shorthand-properties',\n      '@babel/plugin-transform-arrow-functions',\n      '@babel/plugin-proposal-optional-chaining',\n      '@babel/plugin-proposal-nullish-coalescing-operator',\n      ['@babel/plugin-transform-template-literals', { loose: true }],\n    ],\n    ast: true,\n    babelrc: false,\n    configFile: false,\n    inputSourceMap: codeObject.map,\n  });\n\n  assert(transformed, \"'transformed' is undefined\");\n  assert(transformed.ast, \"'transformed.ast' is undefined\");\n\n  traverse(transformed.ast, {\n    Identifier(path) {\n      if (!path.isReferencedIdentifier()) {\n        return;\n      }\n      const name = path.node.name;\n      if (\n        globals.has(name) ||\n        (!isArrowFunctionExpression(fun.node) &&\n          !isObjectMethod(fun.node) &&\n          fun.node.id &&\n          fun.node.id.name === name)\n      ) {\n        return;\n      }\n\n      const parentNode = path.parent;\n\n      if (\n        parentNode.type === 'MemberExpression' &&\n        parentNode.property === path.node &&\n        !parentNode.computed\n      ) {\n        return;\n      }\n\n      if (\n        parentNode.type === 'ObjectProperty' &&\n        path.parentPath.parent.type === 'ObjectExpression' &&\n        path.node !== parentNode.value\n      ) {\n        return;\n      }\n\n      let currentScope = path.scope;\n\n      while (currentScope != null) {\n        if (currentScope.bindings[name] != null) {\n          return;\n        }\n        currentScope = currentScope.parent;\n      }\n      closure.set(name, path.node);\n    },\n  });\n\n  const variables = Array.from(closure.values());\n\n  const privateFunctionId = identifier('_f');\n  const clone = cloneNode(fun.node);\n  const funExpression = isBlockStatement(clone.body)\n    ? functionExpression(null, clone.params, clone.body)\n    : clone;\n\n  const [funString, sourceMapString] = buildWorkletString(\n    transformed.ast,\n    variables,\n    functionName,\n    transformed.map\n  );\n  assert(funString, \"'funString' is undefined\");\n  const workletHash = hash(funString);\n\n  let location = state.file.opts.filename;\n  if (state.opts.relativeSourceLocation) {\n    const path = require('path');\n    location = path.relative(state.cwd, location);\n  }\n\n  let lineOffset = 1;\n  if (closure.size > 0) {\n    // When worklet captures some variables, we append closure destructing at\n    // the beginning of the function body. This effectively results in line\n    // numbers shifting by the number of captured variables (size of the\n    // closure) + 2 (for the opening and closing brackets of the destruct\n    // statement)\n    lineOffset -= closure.size + 2;\n  }\n\n  const pathForStringDefinitions = fun.parentPath.isProgram()\n    ? fun\n    : (fun.findParent(\n        (path) => (path.parentPath as NodePath<BabelNode>).isProgram() // lack of this 'as ...' causes typescript error on Windows CI build\n      ) as NodePath<BabelNode>); // lack of this 'as ...' this causes typescript error on Windows CI build\n\n  const initDataId = (\n    pathForStringDefinitions.parentPath as NodePath<BabelNode>\n  ).scope // lack of this 'as ...' this causes typescript error on Windows CI build\n    .generateUidIdentifier(`worklet_${workletHash}_init_data`);\n\n  const initDataObjectExpression = objectExpression([\n    objectProperty(identifier('code'), stringLiteral(funString)),\n    objectProperty(identifier('location'), stringLiteral(location)),\n  ]);\n\n  if (sourceMapString) {\n    initDataObjectExpression.properties.push(\n      objectProperty(identifier('sourceMap'), stringLiteral(sourceMapString))\n    );\n  }\n\n  pathForStringDefinitions.insertBefore(\n    variableDeclaration('const', [\n      variableDeclarator(initDataId, initDataObjectExpression),\n    ])\n  );\n\n  assert(\n    !isFunctionDeclaration(funExpression),\n    \"'funExpression' is a 'functionDeclaration'\"\n  );\n  assert(\n    !isObjectMethod(funExpression),\n    \"'funExpression' is an 'objectMethod'\"\n  );\n\n  const statements: Array<\n    VariableDeclaration | ExpressionStatement | ReturnStatement\n  > = [\n    variableDeclaration('const', [\n      variableDeclarator(privateFunctionId, funExpression),\n    ]),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(privateFunctionId, identifier('_closure'), false),\n        objectExpression(\n          variables.map((variable) =>\n            objectProperty(identifier(variable.name), variable, false, true)\n          )\n        )\n      )\n    ),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(privateFunctionId, identifier('__initData'), false),\n        initDataId\n      )\n    ),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(privateFunctionId, identifier('__workletHash'), false),\n        numericLiteral(workletHash)\n      )\n    ),\n  ];\n\n  if (!isRelease()) {\n    statements.unshift(\n      variableDeclaration('const', [\n        variableDeclarator(\n          identifier('_e'),\n          arrayExpression([\n            newExpression(\n              memberExpression(identifier('global'), identifier('Error')),\n              []\n            ),\n            numericLiteral(lineOffset),\n            numericLiteral(-27), // the placement of opening bracket after Exception in line that defined '_e' variable\n          ])\n        ),\n      ])\n    );\n    statements.push(\n      expressionStatement(\n        assignmentExpression(\n          '=',\n          memberExpression(\n            privateFunctionId,\n            identifier('__stackDetails'),\n            false\n          ),\n          identifier('_e')\n        )\n      )\n    );\n  }\n\n  statements.push(returnStatement(privateFunctionId));\n\n  const newFun = functionExpression(\n    // !isArrowFunctionExpression(fun.node) ? fun.node.id : undefined, // [TO DO] --- this never worked\n    undefined,\n    [],\n    blockStatement(statements)\n  );\n\n  return newFun;\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  ObjectMethod,\n  identifier,\n  isIdentifier,\n  isFunctionParent,\n  objectProperty,\n  callExpression,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { makeWorklet } from './makeWorklet';\n\nexport function processWorkletObjectMethod(\n  path: NodePath<ObjectMethod>,\n  state: ReanimatedPluginPass\n) {\n  // Replaces ObjectMethod with a workletized version of itself.\n\n  if (!isFunctionParent(path)) {\n    return;\n  }\n\n  const newFun = makeWorklet(path, state);\n\n  const replacement = objectProperty(\n    identifier(isIdentifier(path.node.key) ? path.node.key.name : ''),\n    callExpression(newFun, [])\n  );\n\n  path.replaceWith(replacement);\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  callExpression,\n  isScopable,\n  isExportNamedDeclaration,\n  isArrowFunctionExpression,\n  variableDeclaration,\n  isFunctionParent,\n  variableDeclarator,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { makeWorklet } from './makeWorklet';\n\nexport function processWorkletFunction(\n  fun: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n) {\n  // Replaces FunctionDeclaration, FunctionExpression or ArrowFunctionExpression\n  // with a workletized version of itself.\n\n  if (!isFunctionParent(fun)) {\n    return;\n  }\n\n  const newFun = makeWorklet(fun, state);\n\n  const replacement = callExpression(newFun, []);\n\n  // we check if function needs to be assigned to variable declaration.\n  // This is needed if function definition directly in a scope. Some other ways\n  // where function definition can be used is for example with variable declaration:\n  // const ggg = function foo() { }\n  // ^ in such a case we don't need to define variable for the function\n  const needDeclaration =\n    isScopable(fun.parent) || isExportNamedDeclaration(fun.parent);\n  fun.replaceWith(\n    !isArrowFunctionExpression(fun.node) && fun.node.id && needDeclaration\n      ? variableDeclaration('const', [\n          variableDeclarator(fun.node.id, replacement),\n        ])\n      : replacement\n  );\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  CallExpression,\n  isSequenceExpression,\n  isObjectExpression,\n  ObjectMethod,\n  ObjectProperty,\n  isObjectMethod,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { processWorkletObjectMethod } from './processWorkletObjectMethod';\nimport { processWorkletFunction } from './processWorkletFunction';\n\nconst functionArgsToWorkletize = new Map([\n  ['useFrameCallback', [0]],\n  ['useAnimatedStyle', [0]],\n  ['useAnimatedProps', [0]],\n  ['createAnimatedPropAdapter', [0]],\n  ['useDerivedValue', [0]],\n  ['useAnimatedScrollHandler', [0]],\n  ['useAnimatedReaction', [0, 1]],\n  ['useWorkletCallback', [0]],\n  // animations' callbacks\n  ['withTiming', [2]],\n  ['withSpring', [2]],\n  ['withDecay', [1]],\n  ['withRepeat', [3]],\n]);\n\nconst objectHooks = new Set([\n  'useAnimatedGestureHandler',\n  'useAnimatedScrollHandler',\n]);\n\nexport function processWorklets(\n  path: NodePath<CallExpression>,\n  state: ReanimatedPluginPass\n) {\n  const callee = isSequenceExpression(path.node.callee)\n    ? path.node.callee.expressions[path.node.callee.expressions.length - 1]\n    : path.node.callee;\n\n  let name = '';\n  if ('name' in callee) {\n    name = callee.name;\n  } else if ('property' in callee && 'name' in callee.property) {\n    name = callee.property.name;\n  }\n  // else name = 'anonymous'; --- might add it in the future [TO DO]\n\n  if (\n    objectHooks.has(name) &&\n    isObjectExpression(\n      (path.get('arguments.0') as NodePath<CallExpression['arguments'][number]>)\n        .node\n    )\n  ) {\n    const properties = path.get('arguments.0.properties') as Array<\n      NodePath<ObjectMethod | ObjectProperty>\n    >;\n    for (const property of properties) {\n      if (isObjectMethod(property.node)) {\n        processWorkletObjectMethod(property as NodePath<ObjectMethod>, state);\n      } else {\n        const value = property.get('value') as NodePath<\n          ObjectProperty['value']\n        >;\n        processWorkletFunction(\n          value as NodePath<\n            FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n          >,\n          state\n        ); // temporarily given 3 types [TO DO]\n      }\n    }\n  } else {\n    const indexes = functionArgsToWorkletize.get(name);\n    if (Array.isArray(indexes)) {\n      indexes.forEach((index) => {\n        processWorkletFunction(\n          path.get(`arguments.${index}`) as NodePath<\n            FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n          >,\n          state\n        ); // temporarily given 3 types [TO DO]\n      });\n    }\n  }\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  isBlockStatement,\n  isDirectiveLiteral,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { processWorkletFunction } from './processWorkletFunction';\n\nexport function processIfWorkletNode(\n  fun: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n) {\n  fun.traverse({\n    DirectiveLiteral(path) {\n      const value = path.node.value;\n      if (\n        value === 'worklet' &&\n        path.getFunctionParent() === fun &&\n        isBlockStatement(fun.node.body)\n      ) {\n        // make sure \"worklet\" is listed among directives for the fun\n        // this is necessary as because of some bug, babel will attempt to\n        // process replaced function if it is nested inside another function\n        const directives = fun.node.body.directives;\n        if (\n          directives &&\n          directives.length > 0 &&\n          directives.some(\n            (directive) =>\n              isDirectiveLiteral(directive.value) &&\n              directive.value.value === 'worklet'\n          )\n        ) {\n          processWorkletFunction(fun, state);\n        }\n      }\n    },\n  });\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  isIdentifier,\n  isCallExpression,\n  Expression,\n  isMemberExpression,\n  isExpression,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { processWorkletFunction } from './processWorkletFunction';\n\nconst gestureHandlerGestureObjects = new Set([\n  // from https://github.com/software-mansion/react-native-gesture-handler/blob/new-api/src/handlers/gestures/gestureObjects.ts\n  'Tap',\n  'Pan',\n  'Pinch',\n  'Rotation',\n  'Fling',\n  'LongPress',\n  'ForceTouch',\n  'Native',\n  'Manual',\n  'Race',\n  'Simultaneous',\n  'Exclusive',\n]);\n\nconst gestureHandlerBuilderMethods = new Set([\n  'onBegin',\n  'onStart',\n  'onEnd',\n  'onFinalize',\n  'onUpdate',\n  'onChange',\n  'onTouchesDown',\n  'onTouchesMove',\n  'onTouchesUp',\n  'onTouchesCancelled',\n]);\n\nexport function processIfGestureHandlerEventCallbackFunctionNode(\n  fun: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n) {\n  // Auto-workletizes React Native Gesture Handler callback functions.\n  // Detects `Gesture.Tap().onEnd(<fun>)` or similar, but skips `something.onEnd(<fun>)`.\n  // Supports method chaining as well, e.g. `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`.\n\n  // Example #1: `Gesture.Tap().onEnd(<fun>)`\n  /*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: Identifier('Gesture')\n          property: Identifier('Tap')\n        )\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun]\n  )\n  */\n\n  // Example #2: `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`\n  /*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: CallExpression(\n            callee: MemberExpression(\n              object: CallExpression(\n                callee: MemberExpression(\n                  object: Identifier('Gesture')\n                  property: Identifier('Tap')\n                )\n              )\n              property: Identifier('onStart')\n            )\n            arguments: [fun1]\n          )\n          property: Identifier('onUpdate')\n        )\n        arguments: [fun2]\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun3]\n  )\n  */\n\n  if (\n    isCallExpression(fun.parent) &&\n    isExpression(fun.parent.callee) &&\n    isGestureObjectEventCallbackMethod(fun.parent.callee)\n  ) {\n    processWorkletFunction(fun, state);\n  }\n}\n\nfunction isGestureObjectEventCallbackMethod(node: Expression) {\n  // Checks if node matches the pattern `Gesture.Foo()[*].onBar`\n  // where `[*]` represents any number of method calls.\n  return (\n    isMemberExpression(node) &&\n    isIdentifier(node.property) &&\n    gestureHandlerBuilderMethods.has(node.property.name) &&\n    containsGestureObject(node.object)\n  );\n}\n\nfunction containsGestureObject(node: Expression) {\n  // Checks if node matches the pattern `Gesture.Foo()[*]`\n  // where `[*]` represents any number of chained method calls, like `.something(42)`.\n\n  // direct call\n  if (isGestureObject(node)) {\n    return true;\n  }\n\n  // method chaining\n  if (\n    isCallExpression(node) &&\n    isMemberExpression(node.callee) &&\n    containsGestureObject(node.callee.object)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isGestureObject(node: Expression) {\n  // Checks if node matches `Gesture.Tap()` or similar.\n  /*\n  node: CallExpression(\n    callee: MemberExpression(\n      object: Identifier('Gesture')\n      property: Identifier('Tap')\n    )\n  )\n  */\n  return (\n    isCallExpression(node) &&\n    isMemberExpression(node.callee) &&\n    isIdentifier(node.callee.object) &&\n    node.callee.object.name === 'Gesture' &&\n    isIdentifier(node.callee.property) &&\n    gestureHandlerGestureObjects.has(node.callee.property.name)\n  );\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  MemberExpression,\n  callExpression,\n  arrowFunctionExpression,\n  isMemberExpression,\n  isArrayExpression,\n  isObjectExpression,\n  ArrayExpression,\n  ObjectExpression,\n  isObjectProperty,\n  JSXAttribute,\n  isJSXExpressionContainer,\n  Expression,\n  identifier,\n  stringLiteral,\n  expressionStatement,\n  memberExpression,\n  returnStatement,\n  blockStatement,\n  ObjectProperty,\n  isIdentifier,\n} from '@babel/types';\nimport { isRelease } from './utils';\nimport { ReanimatedPluginPass } from './types';\n\nfunction generateInlineStylesWarning(path: NodePath<MemberExpression>) {\n  // replaces `sharedvalue.value` with `(()=>{console.warn(require('react-native-reanimated').getUseOfValueInStyleWarning());return sharedvalue.value;})()`\n  return callExpression(\n    arrowFunctionExpression(\n      [],\n      blockStatement([\n        expressionStatement(\n          callExpression(\n            memberExpression(identifier('console'), identifier('warn')),\n            [\n              callExpression(\n                memberExpression(\n                  callExpression(identifier('require'), [\n                    stringLiteral('react-native-reanimated'),\n                  ]),\n                  identifier('getUseOfValueInStyleWarning')\n                ),\n                []\n              ),\n            ]\n          )\n        ),\n        returnStatement(path.node),\n      ])\n    ),\n    []\n  );\n}\n\nfunction processPropertyValueForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n) {\n  // if it's something like object.value then raise a warning\n  if (isMemberExpression(path.node) && isIdentifier(path.node.property)) {\n    if (path.node.property.name === 'value') {\n      path.replaceWith(\n        generateInlineStylesWarning(path as NodePath<MemberExpression>)\n      );\n    }\n  }\n}\n\nfunction processTransformPropertyForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n) {\n  if (isArrayExpression(path.node)) {\n    const elements = path.get('elements') as Array<\n      NodePath<ArrayExpression['elements'][number]>\n    >;\n    for (const element of elements) {\n      if (isObjectExpression(element.node)) {\n        processStyleObjectForInlineStylesWarning(\n          element as NodePath<ObjectExpression>\n        ); // why is it not inferred? [TO DO]\n      }\n    }\n  }\n}\n\nfunction processStyleObjectForInlineStylesWarning(\n  path: NodePath<ObjectExpression>\n) {\n  const properties = path.get('properties') as Array<\n    NodePath<ObjectExpression['properties'][number]>\n  >;\n  for (const property of properties) {\n    if (!isObjectProperty(property.node)) {\n      continue;\n    }\n    const value = property.get('value') as NodePath<ObjectProperty['value']>;\n    if (isObjectProperty(property)) {\n      if (\n        isIdentifier(property.node.key) &&\n        property.node.key.name === 'transform'\n      ) {\n        processTransformPropertyForInlineStylesWarning(value);\n      } else {\n        processPropertyValueForInlineStylesWarning(value);\n      }\n    }\n  }\n}\n\nexport function processInlineStylesWarning(\n  path: NodePath<JSXAttribute>,\n  state: ReanimatedPluginPass\n) {\n  if (isRelease()) {\n    return;\n  }\n  if (state.opts.disableInlineStylesWarning) {\n    return;\n  }\n  if (path.node.name.name !== 'style') {\n    return;\n  }\n  if (!isJSXExpressionContainer(path.node.value)) {\n    return;\n  }\n\n  const expression = path\n    .get('value')\n    .get('expression') as NodePath<Expression>;\n  // style={[{...}, {...}]}\n  if (isArrayExpression(expression.node)) {\n    const elements = expression.get('elements') as Array<\n      NodePath<ArrayExpression['elements'][number]>\n    >;\n    for (const element of elements) {\n      if (isObjectExpression(element.node)) {\n        processStyleObjectForInlineStylesWarning(\n          element as NodePath<ObjectExpression>\n        ); // why is it not inferred? [TO DO]\n      }\n    }\n  }\n  // style={{...}}\n  else if (isObjectExpression(expression.node)) {\n    processStyleObjectForInlineStylesWarning(\n      expression as NodePath<ObjectExpression>\n    ); // why is it not inferred? [TO DO]\n  }\n}\n", "import { NodePath } from '@babel/core';\nimport {\n  DirectiveLiteral,\n  expressionStatement,\n  assignmentExpression,\n  memberExpression,\n  identifier,\n  stringLiteral,\n  FunctionDeclaration,\n} from '@babel/types';\n\nexport function injectVersion(path: NodePath<DirectiveLiteral>) {\n  // We want to inject plugin's version only once,\n  // hence we have a Directive Literal line in Reanimated code.\n  // See src/reanimated2/platform-specific/checkPluginVersion.ts\n  // to see the details of this implementation.\n  if (path.node.value !== 'inject Reanimated Babel plugin version') {\n    return;\n  }\n  const injectedName = '_REANIMATED_VERSION_BABEL_PLUGIN';\n  const versionString = require('../../package.json').version;\n  const pluginVersionNode = expressionStatement(\n    assignmentExpression(\n      '=',\n      memberExpression(identifier('global'), identifier(injectedName)),\n      stringLiteral(versionString)\n    )\n  );\n\n  const functionParent = (\n    path.getFunctionParent() as NodePath<FunctionDeclaration>\n  ).node;\n  // DirectiveLiteral is in property of its function parent 'directives' hence we cannot just replace it.\n  functionParent.body.directives = [];\n  functionParent.body.body.unshift(pluginVersionNode);\n}\n", "import { PluginItem, NodePath } from '@babel/core';\nimport { globals } from './commonObjects';\nimport {\n  CallExpression,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  DirectiveLiteral,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { processWorklets } from './processWorklets';\nimport { processIfWorkletNode } from './processIfWorkletNode';\nimport { processIfGestureHandlerEventCallbackFunctionNode } from './processIfGestureHandlerEventCallbackFunctionNode';\nimport { processInlineStylesWarning } from './processInlineStylesWarning';\nimport { injectVersion } from './injectVersion';\n\nmodule.exports = function (): PluginItem {\n  return {\n    pre() {\n      // allows adding custom globals such as host-functions\n      if (this.opts != null && Array.isArray(this.opts.globals)) {\n        this.opts.globals.forEach((name: string) => {\n          globals.add(name);\n        });\n      }\n    },\n    visitor: {\n      DirectiveLiteral: {\n        enter(path: NodePath<DirectiveLiteral>) {\n          injectVersion(path);\n        },\n      },\n      CallExpression: {\n        enter(path: NodePath<CallExpression>, state: ReanimatedPluginPass) {\n          processWorklets(path, state);\n        },\n      },\n      'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression': {\n        enter(\n          path: NodePath<\n            FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n          >,\n          state: ReanimatedPluginPass\n        ) {\n          processIfWorkletNode(path, state);\n          processIfGestureHandlerEventCallbackFunctionNode(path, state);\n        },\n      },\n      JSXAttribute: {\n        enter(path, state) {\n          processInlineStylesWarning(path, state);\n        },\n      },\n    },\n  };\n};\n"],
  "mappings": "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",
  "names": ["exports", "exports", "commonObjects_1", "exports", "exports", "exports", "exports", "exports", "exports", "exports", "exports"]
>>>>>>> @tjzel/plugins-move-throws-to-asserts
}
