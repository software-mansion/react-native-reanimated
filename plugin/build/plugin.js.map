{
  "version": 3,
  "sources": ["../src/utils.ts", "../src/buildWorkletString.ts", "../src/globals.ts", "../src/makeWorklet.ts", "../src/processWorkletObjectMethod.ts", "../src/processIfWorkletFunction.ts", "../src/processForCalleesWorklets.ts", "../src/processIfWorkletNode.ts", "../src/processInlineStylesWarning.ts", "../src/isGestureHandlerEventCallback.ts", "../src/isLayoutAnimationCallback.ts", "../src/processIfCallback.ts", "../src/addCustomGlobals.ts", "../src/plugin.ts"],
  "sourcesContent": ["export function isRelease() {\n  return !!process.env.BABEL_ENV?.match(/(prod|release|stag[ei])/i);\n}\n", "import type { BabelFileResult, NodePath, PluginItem } from '@babel/core';\nimport { transformSync } from '@babel/core';\nimport generate from '@babel/generator';\nimport type {\n  File as BabelFile,\n  ExpressionStatement,\n  FunctionDeclaration,\n  Identifier,\n  VariableDeclaration,\n} from '@babel/types';\nimport {\n  functionExpression,\n  identifier,\n  isArrowFunctionExpression,\n  isBlockStatement,\n  isExpression,\n  isExpressionStatement,\n  isFunctionDeclaration,\n  isObjectMethod,\n  isProgram,\n  memberExpression,\n  objectPattern,\n  objectProperty,\n  thisExpression,\n  variableDeclaration,\n  variableDeclarator,\n} from '@babel/types';\nimport { strict as assert } from 'assert';\nimport * as convertSourceMap from 'convert-source-map';\nimport * as fs from 'fs';\nimport { isRelease } from './utils';\nimport type { WorkletizableFunction } from './types';\n\nconst MOCK_SOURCE_MAP = 'mock source map';\n\nexport function buildWorkletString(\n  fun: BabelFile,\n  closureVariables: Array<Identifier>,\n  name: string,\n  inputMap: BabelFileResult['map']\n): Array<string | null | undefined> {\n  const draftExpression = (fun.program.body.find((obj) =>\n    isFunctionDeclaration(obj)\n  ) ||\n    fun.program.body.find((obj) => isExpressionStatement(obj)) ||\n    undefined) as FunctionDeclaration | ExpressionStatement | undefined;\n\n  assert(draftExpression, '[Reanimated] `draftExpression` is undefined.');\n\n  const expression = isFunctionDeclaration(draftExpression)\n    ? draftExpression\n    : draftExpression.expression;\n\n  assert(\n    'params' in expression,\n    \"'params' property is undefined in 'expression'\"\n  );\n  assert(\n    isBlockStatement(expression.body),\n    '[Reanimated] `expression.body` is not a `BlockStatement`'\n  );\n\n  const workletFunction = functionExpression(\n    identifier(name),\n    expression.params,\n    expression.body\n  );\n\n  const code = generate(workletFunction).code;\n\n  assert(inputMap, '[Reanimated] `inputMap` is undefined.');\n\n  const includeSourceMap = !isRelease();\n\n  if (includeSourceMap) {\n    // Clear contents array (should be empty anyways)\n    inputMap.sourcesContent = [];\n    // Include source contents in source map, because Flipper/iframe is not\n    // allowed to read files from disk.\n    for (const sourceFile of inputMap.sources) {\n      inputMap.sourcesContent.push(\n        fs.readFileSync(sourceFile).toString('utf-8')\n      );\n    }\n  }\n\n  const transformed = transformSync(code, {\n    plugins: [prependClosureVariablesIfNecessary(closureVariables)],\n    compact: true,\n    sourceMaps: includeSourceMap,\n    inputSourceMap: inputMap,\n    ast: false,\n    babelrc: false,\n    configFile: false,\n    comments: false,\n  });\n\n  assert(transformed, '[Reanimated] `transformed` is null.');\n\n  let sourceMap;\n  if (includeSourceMap) {\n    if (shouldMockSourceMap()) {\n      sourceMap = MOCK_SOURCE_MAP;\n    } else {\n      sourceMap = convertSourceMap.fromObject(transformed.map).toObject();\n      // sourcesContent field contains a full source code of the file which contains the worklet\n      // and is not needed by the source map interpreter in order to symbolicate a stack trace.\n      // Therefore, we remove it to reduce the bandwith and avoid sending it potentially multiple times\n      // in files that contain multiple worklets. Along with sourcesContent.\n      delete sourceMap.sourcesContent;\n    }\n  }\n\n  return [transformed.code, JSON.stringify(sourceMap)];\n}\n\nfunction shouldMockSourceMap() {\n  // We don't want to pollute tests with source maps so we mock it\n  // for all tests (except one)\n  return process.env.REANIMATED_JEST_SHOULD_MOCK_SOURCE_MAP === '1';\n}\n\nfunction prependClosure(\n  path: NodePath<WorkletizableFunction>,\n  closureVariables: Array<Identifier>,\n  closureDeclaration: VariableDeclaration\n) {\n  if (closureVariables.length === 0 || !isProgram(path.parent)) {\n    return;\n  }\n\n  if (!isExpression(path.node.body)) {\n    path.node.body.body.unshift(closureDeclaration);\n  }\n}\n\nfunction prependRecursiveDeclaration(path: NodePath<WorkletizableFunction>) {\n  if (\n    isProgram(path.parent) &&\n    !isArrowFunctionExpression(path.node) &&\n    !isObjectMethod(path.node) &&\n    path.node.id &&\n    path.scope.parent\n  ) {\n    const hasRecursiveCalls =\n      path.scope.parent.bindings[path.node.id.name]?.references > 0;\n    if (hasRecursiveCalls) {\n      path.node.body.body.unshift(\n        variableDeclaration('const', [\n          variableDeclarator(\n            identifier(path.node.id.name),\n            memberExpression(thisExpression(), identifier('_recur'))\n          ),\n        ])\n      );\n    }\n  }\n}\n\nfunction prependClosureVariablesIfNecessary(\n  closureVariables: Array<Identifier>\n): PluginItem {\n  const closureDeclaration = variableDeclaration('const', [\n    variableDeclarator(\n      objectPattern(\n        closureVariables.map((variable) =>\n          objectProperty(\n            identifier(variable.name),\n            identifier(variable.name),\n            false,\n            true\n          )\n        )\n      ),\n      memberExpression(thisExpression(), identifier('__closure'))\n    ),\n  ]);\n\n  return {\n    visitor: {\n      'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression|ObjectMethod':\n        (path: NodePath<WorkletizableFunction>) => {\n          prependClosure(path, closureVariables, closureDeclaration);\n          prependRecursiveDeclaration(path);\n        },\n    },\n  };\n}\n", "export const defaultGlobals = new Set([\n  // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\n\n  // Note that objects' properties don't need to be listed since we always only capture the whole object,\n  // e.g. `global.__ErrorUtils` or `Intl.DateTimeFormat`.\n\n  // Value properties\n  'globalThis',\n  'Infinity',\n  'NaN',\n  'undefined',\n\n  // Function properties\n  'eval',\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n  'escape',\n  'unescape',\n\n  // Fundamental objects\n  'Object',\n  'Function',\n  'Boolean',\n  'Symbol',\n\n  // Error objects\n  'Error',\n  'AggregateError',\n  'EvalError',\n  'RangeError',\n  'ReferenceError',\n  'SyntaxError',\n  'TypeError',\n  'URIError',\n  'InternalError',\n\n  // Numbers and dates\n  'Number',\n  'BigInt',\n  'Math',\n  'Date',\n\n  // Text processing\n  'String',\n  'RegExp',\n\n  // Indexed collections\n  'Array',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'BigInt64Array',\n  'BigUint64Array',\n  'Float32Array',\n  'Float64Array',\n\n  // Keyed collections\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n\n  // Structured data\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Atomics',\n  'JSON',\n\n  // Managing memory\n  'WeakRef',\n  'FinalizationRegistry',\n\n  // Control abstraction objects\n  'Iterator',\n  'AsyncIterator',\n  'Promise',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'Generator',\n  'AsyncGenerator',\n  'AsyncFunction',\n\n  // Reflection\n  'Reflect',\n  'Proxy',\n\n  // Internationalization\n  'Intl',\n\n  // Other stuff\n  'null',\n  'this',\n  'global',\n  'console',\n  'performance',\n  'queueMicrotask',\n  'requestAnimationFrame',\n  'setImmediate',\n  'arguments', // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n\n  // Hermes\n  'HermesInternal',\n\n  // Reanimated\n  '_WORKLET',\n  '_log',\n  '_toString',\n  '_scheduleOnJS',\n  '_makeShareableClone',\n  '_updateDataSynchronously',\n  '_updatePropsPaper',\n  '_updatePropsFabric',\n  '_removeFromPropsRegistry',\n  '_measurePaper',\n  '_measureFabric',\n  '_scrollToPaper',\n  '_dispatchCommandPaper',\n  '_dispatchCommandFabric',\n  '_setGestureState',\n  '_notifyAboutProgress',\n  '_notifyAboutEnd',\n  '_runOnUIQueue',\n]);\n\nexport let globals: Set<string>;\n\nexport function initializeGlobals() {\n  globals = new Set(defaultGlobals);\n}\n", "/* eslint-disable @typescript-eslint/no-var-requires */\nimport type { NodePath } from '@babel/core';\nimport { transformSync, traverse } from '@babel/core';\nimport generate from '@babel/generator';\nimport type {\n  File as BabelFile,\n  ExpressionStatement,\n  FunctionExpression,\n  Identifier,\n  ReturnStatement,\n  VariableDeclaration,\n} from '@babel/types';\nimport {\n  arrayExpression,\n  assignmentExpression,\n  blockStatement,\n  cloneNode,\n  expressionStatement,\n  functionExpression,\n  identifier,\n  isBlockStatement,\n  isFunctionDeclaration,\n  isFunctionExpression,\n  isIdentifier,\n  isMemberExpression,\n  isObjectExpression,\n  isObjectMethod,\n  isObjectProperty,\n  isProgram,\n  memberExpression,\n  newExpression,\n  numericLiteral,\n  objectExpression,\n  objectProperty,\n  returnStatement,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator,\n} from '@babel/types';\nimport { strict as assert } from 'assert';\nimport { relative } from 'path';\nimport { buildWorkletString } from './buildWorkletString';\nimport { globals } from './globals';\nimport type { ReanimatedPluginPass, WorkletizableFunction } from './types';\nimport { isRelease } from './utils';\n\nconst REAL_VERSION = require('../../package.json').version;\nconst MOCK_VERSION = 'x.y.z';\n\nexport function makeWorklet(\n  fun: NodePath<WorkletizableFunction>,\n  state: ReanimatedPluginPass\n): FunctionExpression {\n  // Returns a new FunctionExpression which is a workletized version of provided\n  // FunctionDeclaration, FunctionExpression, ArrowFunctionExpression or ObjectMethod.\n\n  removeWorkletDirective(fun);\n\n  // We use copy because some of the plugins don't update bindings and\n  // some even break them\n  assert(\n    state.file.opts.filename,\n    '[Reanimated] `state.file.opts.filename` is undefined.'\n  );\n\n  const codeObject = generate(fun.node, {\n    sourceMaps: true,\n    sourceFileName: state.file.opts.filename,\n  });\n\n  // We need to add a newline at the end, because there could potentially be a\n  // comment after the function that gets included here, and then the closing\n  // bracket would become part of the comment thus resulting in an error, since\n  // there is a missing closing bracket.\n  codeObject.code =\n    '(' + (isObjectMethod(fun) ? 'function ' : '') + codeObject.code + '\\n)';\n\n  const transformed = transformSync(codeObject.code, {\n    filename: state.file.opts.filename,\n    presets: [require.resolve('@babel/preset-typescript')],\n    plugins: [\n      require.resolve('@babel/plugin-transform-shorthand-properties'),\n      require.resolve('@babel/plugin-transform-arrow-functions'),\n      require.resolve('@babel/plugin-proposal-optional-chaining'),\n      require.resolve('@babel/plugin-proposal-nullish-coalescing-operator'),\n      [\n        require.resolve('@babel/plugin-transform-template-literals'),\n        { loose: true },\n      ],\n    ],\n    ast: true,\n    babelrc: false,\n    configFile: false,\n    inputSourceMap: codeObject.map,\n  });\n\n  assert(transformed, '[Reanimated] `transformed` is undefined.');\n  assert(transformed.ast, '[Reanimated] `transformed.ast` is undefined.');\n\n  const variables = makeArrayFromCapturedBindings(transformed.ast, fun);\n\n  const functionName = makeWorkletName(fun);\n  const functionIdentifier = identifier(functionName);\n\n  const clone = cloneNode(fun.node);\n  const funExpression = isBlockStatement(clone.body)\n    ? functionExpression(null, clone.params, clone.body)\n    : clone;\n\n  const [funString, sourceMapString] = buildWorkletString(\n    transformed.ast,\n    variables,\n    functionName,\n    transformed.map\n  );\n  assert(funString, '[Reanimated] `funString` is undefined.');\n  const workletHash = hash(funString);\n\n  let lineOffset = 1;\n  if (variables.length > 0) {\n    // When worklet captures some variables, we append closure destructing at\n    // the beginning of the function body. This effectively results in line\n    // numbers shifting by the number of captured variables (size of the\n    // closure) + 2 (for the opening and closing brackets of the destruct\n    // statement)\n    lineOffset -= variables.length + 2;\n  }\n\n  const pathForStringDefinitions = fun.parentPath.isProgram()\n    ? fun\n    : fun.findParent((path) => isProgram(path.parentPath));\n  assert(\n    pathForStringDefinitions,\n    '[Reanimated] `pathForStringDefinitions` is null.'\n  );\n  assert(\n    pathForStringDefinitions.parentPath,\n    '[Reanimated] `pathForStringDefinitions.parentPath` is null.'\n  );\n\n  const initDataId =\n    pathForStringDefinitions.parentPath.scope.generateUidIdentifier(\n      `worklet_${workletHash}_init_data`\n    );\n\n  const initDataObjectExpression = objectExpression([\n    objectProperty(identifier('code'), stringLiteral(funString)),\n  ]);\n\n  // When testing with jest I noticed that environment variables are set later\n  // than some functions are evaluated. E.g. this cannot be above this function\n  // because it would always evaluate to true.\n  const shouldInjectLocation = !isRelease();\n  if (shouldInjectLocation) {\n    let location = state.file.opts.filename;\n    if (state.opts.relativeSourceLocation) {\n      location = relative(state.cwd, location);\n    }\n\n    initDataObjectExpression.properties.push(\n      objectProperty(identifier('location'), stringLiteral(location))\n    );\n  }\n\n  if (sourceMapString) {\n    initDataObjectExpression.properties.push(\n      objectProperty(identifier('sourceMap'), stringLiteral(sourceMapString))\n    );\n  }\n\n  const shouldInjectVersion = !isRelease();\n  if (shouldInjectVersion) {\n    initDataObjectExpression.properties.push(\n      objectProperty(\n        identifier('version'),\n        stringLiteral(shouldMockVersion() ? MOCK_VERSION : REAL_VERSION)\n      )\n    );\n  }\n\n  pathForStringDefinitions.insertBefore(\n    variableDeclaration('const', [\n      variableDeclarator(initDataId, initDataObjectExpression),\n    ])\n  );\n\n  assert(\n    !isFunctionDeclaration(funExpression),\n    '[Reanimated] `funExpression` is a `FunctionDeclaration`.'\n  );\n  assert(\n    !isObjectMethod(funExpression),\n    '[Reanimated] `funExpression` is an `ObjectMethod`.'\n  );\n\n  const statements: Array<\n    VariableDeclaration | ExpressionStatement | ReturnStatement\n  > = [\n    variableDeclaration('const', [\n      variableDeclarator(functionIdentifier, funExpression),\n    ]),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(functionIdentifier, identifier('__closure'), false),\n        objectExpression(\n          variables.map((variable) =>\n            objectProperty(identifier(variable.name), variable, false, true)\n          )\n        )\n      )\n    ),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(functionIdentifier, identifier('__initData'), false),\n        initDataId\n      )\n    ),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(\n          functionIdentifier,\n          identifier('__workletHash'),\n          false\n        ),\n        numericLiteral(workletHash)\n      )\n    ),\n  ];\n\n  if (!isRelease()) {\n    statements.unshift(\n      variableDeclaration('const', [\n        variableDeclarator(\n          identifier('_e'),\n          arrayExpression([\n            newExpression(\n              memberExpression(identifier('global'), identifier('Error')),\n              []\n            ),\n            numericLiteral(lineOffset),\n            numericLiteral(-27), // the placement of opening bracket after Exception in line that defined '_e' variable\n          ])\n        ),\n      ])\n    );\n    statements.push(\n      expressionStatement(\n        assignmentExpression(\n          '=',\n          memberExpression(\n            functionIdentifier,\n            identifier('__stackDetails'),\n            false\n          ),\n          identifier('_e')\n        )\n      )\n    );\n  }\n\n  statements.push(returnStatement(functionIdentifier));\n\n  const newFun = functionExpression(undefined, [], blockStatement(statements));\n\n  return newFun;\n}\n\nfunction removeWorkletDirective(fun: NodePath<WorkletizableFunction>) {\n  fun.traverse({\n    DirectiveLiteral(path) {\n      if (path.node.value === 'worklet' && path.getFunctionParent() === fun) {\n        path.parentPath.remove();\n      }\n    },\n  });\n}\n\nfunction shouldMockVersion() {\n  // We don't want to pollute tests with current version number so we mock it\n  // for all tests (except one)\n  return process.env.REANIMATED_JEST_SHOULD_MOCK_VERSION === '1';\n}\n\nfunction hash(str: string) {\n  let i = str.length;\n  let hash1 = 5381;\n  let hash2 = 52711;\n\n  while (i--) {\n    const char = str.charCodeAt(i);\n    // eslint-disable-next-line no-bitwise\n    hash1 = (hash1 * 33) ^ char;\n    // eslint-disable-next-line no-bitwise\n    hash2 = (hash2 * 33) ^ char;\n  }\n\n  // eslint-disable-next-line no-bitwise\n  return (hash1 >>> 0) * 4096 + (hash2 >>> 0);\n}\n\nfunction makeWorkletName(fun: NodePath<WorkletizableFunction>) {\n  if (isObjectMethod(fun.node) && isIdentifier(fun.node.key)) {\n    return fun.node.key.name;\n  }\n  if (isFunctionDeclaration(fun.node) && isIdentifier(fun.node.id)) {\n    return fun.node.id.name;\n  }\n  if (isFunctionExpression(fun.node) && isIdentifier(fun.node.id)) {\n    return fun.node.id.name;\n  }\n  return 'anonymous'; // fallback for ArrowFunctionExpression and unnamed FunctionExpression\n}\n\nfunction makeArrayFromCapturedBindings(\n  ast: BabelFile,\n  fun: NodePath<WorkletizableFunction>\n) {\n  const closure = new Map<string, Identifier>();\n\n  // this traversal looks for variables to capture\n  traverse(ast, {\n    Identifier(path) {\n      // we only capture variables that were declared outside of the scope\n      if (!path.isReferencedIdentifier()) {\n        return;\n      }\n      const name = path.node.name;\n      // if the function is named and was added to globals we don't want to add it to closure\n      // hence we check if identifier has that name\n      if (globals.has(name)) {\n        return;\n      }\n      if (\n        'id' in fun.node &&\n        fun.node.id &&\n        fun.node.id.name === name // we don't want to capture function's own name\n      ) {\n        return;\n      }\n\n      const parentNode = path.parent;\n\n      if (\n        isMemberExpression(parentNode) &&\n        parentNode.property === path.node &&\n        !parentNode.computed\n      ) {\n        return;\n      }\n\n      if (\n        isObjectProperty(parentNode) &&\n        isObjectExpression(path.parentPath.parent) &&\n        path.node !== parentNode.value\n      ) {\n        return;\n      }\n\n      let currentScope = path.scope;\n\n      while (currentScope != null) {\n        if (currentScope.bindings[name] != null) {\n          return;\n        }\n        currentScope = currentScope.parent;\n      }\n      closure.set(name, path.node);\n    },\n  });\n\n  return Array.from(closure.values());\n}\n", "import type { NodePath } from '@babel/core';\nimport type { ObjectMethod } from '@babel/types';\nimport {\n  identifier,\n  isIdentifier,\n  isFunctionParent,\n  objectProperty,\n  callExpression,\n} from '@babel/types';\nimport type { ReanimatedPluginPass } from './types';\nimport { makeWorklet } from './makeWorklet';\n\nexport function processWorkletObjectMethod(\n  path: NodePath<ObjectMethod>,\n  state: ReanimatedPluginPass\n) {\n  // Replaces ObjectMethod with a workletized version of itself.\n\n  if (!isFunctionParent(path)) {\n    return;\n  }\n\n  const newFun = makeWorklet(path, state);\n\n  const replacement = objectProperty(\n    identifier(isIdentifier(path.node.key) ? path.node.key.name : ''),\n    callExpression(newFun, [])\n  );\n\n  path.replaceWith(replacement);\n}\n", "import type { NodePath, Node } from '@babel/core';\nimport {\n  callExpression,\n  isScopable,\n  isExportNamedDeclaration,\n  variableDeclaration,\n  variableDeclarator,\n} from '@babel/types';\nimport type { ExplicitWorklet, ReanimatedPluginPass } from './types';\nimport { makeWorklet } from './makeWorklet';\n\n// Replaces FunctionDeclaration, FunctionExpression or ArrowFunctionExpression\n// with a workletized version of itself.\n\nexport function processIfWorkletFunction(\n  path: NodePath<Node>,\n  state: ReanimatedPluginPass\n) {\n  if (\n    path.isFunctionDeclaration() ||\n    path.isFunctionExpression() ||\n    path.isArrowFunctionExpression()\n  ) {\n    processWorkletFunction(path, state);\n  }\n}\n\nfunction processWorkletFunction(\n  path: NodePath<ExplicitWorklet>,\n  state: ReanimatedPluginPass\n) {\n  const newFun = makeWorklet(path, state);\n\n  const replacement = callExpression(newFun, []);\n\n  // we check if function needs to be assigned to variable declaration.\n  // This is needed if function definition directly in a scope. Some other ways\n  // where function definition can be used is for example with variable declaration:\n  // const ggg = function foo() { }\n  // ^ in such a case we don't need to define variable for the function\n  const needDeclaration =\n    isScopable(path.parent) || isExportNamedDeclaration(path.parent);\n  path.replaceWith(\n    'id' in path.node && path.node.id && needDeclaration\n      ? variableDeclaration('const', [\n          variableDeclarator(path.node.id, replacement),\n        ])\n      : replacement\n  );\n}\n", "import type { NodePath } from '@babel/core';\nimport type { CallExpression, ObjectExpression } from '@babel/types';\nimport { isSequenceExpression } from '@babel/types';\nimport type { ReanimatedPluginPass } from './types';\nimport { processWorkletObjectMethod } from './processWorkletObjectMethod';\nimport { processIfWorkletFunction } from './processIfWorkletFunction';\nimport { strict as assert } from 'assert';\n\nconst functionArgsToWorkletize = new Map([\n  ['useFrameCallback', [0]],\n  ['useAnimatedStyle', [0]],\n  ['useAnimatedProps', [0]],\n  ['createAnimatedPropAdapter', [0]],\n  ['useDerivedValue', [0]],\n  ['useAnimatedScrollHandler', [0]],\n  ['useAnimatedReaction', [0, 1]],\n  ['useWorkletCallback', [0]],\n  // animations' callbacks\n  ['withTiming', [2]],\n  ['withSpring', [2]],\n  ['withDecay', [1]],\n  ['withRepeat', [3]],\n  // scheduling functions\n  ['runOnUI', [0]],\n]);\n\nconst objectHooks = new Set([\n  'useAnimatedGestureHandler',\n  'useAnimatedScrollHandler',\n]);\n\nexport function processForCalleesWorklets(\n  path: NodePath<CallExpression>,\n  state: ReanimatedPluginPass\n) {\n  const callee = isSequenceExpression(path.node.callee)\n    ? path.node.callee.expressions[path.node.callee.expressions.length - 1]\n    : path.node.callee;\n\n  // We are looking for objects we know we should workletize\n  // hence if object is not named, we return.\n  const name =\n    'name' in callee\n      ? callee.name\n      : 'property' in callee && 'name' in callee.property\n      ? callee.property.name\n      : undefined;\n  if (name === undefined) {\n    return;\n  }\n\n  if (objectHooks.has(name)) {\n    const workletToProcess = path.get('arguments.0');\n    assert(\n      !Array.isArray(workletToProcess),\n      '[Reanimated] `workletToProcess` is an array.'\n    );\n    if (workletToProcess.isObjectExpression()) {\n      processObjectHook(workletToProcess, state);\n      // useAnimatedScrollHandler can take a function as an argument instead of an ObjectExpression\n      // but useAnimatedGestureHandler can't\n    } else if (name === 'useAnimatedScrollHandler') {\n      processIfWorkletFunction(workletToProcess, state);\n    }\n  } else {\n    const indices = functionArgsToWorkletize.get(name);\n    if (indices === undefined) {\n      return;\n    }\n    processArguments(path, indices, state);\n  }\n}\n\nfunction processObjectHook(\n  path: NodePath<ObjectExpression>,\n  state: ReanimatedPluginPass\n) {\n  const properties = path.get('properties');\n  for (const property of properties) {\n    if (property.isObjectMethod()) {\n      processWorkletObjectMethod(property, state);\n    } else if (property.isObjectProperty()) {\n      const value = property.get('value');\n      processIfWorkletFunction(value, state);\n    } else {\n      throw new Error(\n        `[Reanimated] '${property.type}' as to-be workletized arguments is not supported for object hooks.`\n      );\n    }\n  }\n}\n\nfunction processArguments(\n  path: NodePath<CallExpression>,\n  indices: number[],\n  state: ReanimatedPluginPass\n) {\n  const argumentsArray = path.get('arguments');\n  indices.forEach((index) => {\n    const argumentToWorkletize = argumentsArray[index];\n    if (!argumentToWorkletize) {\n      // workletizable argument doesn't always have to be specified\n      return;\n    }\n    processIfWorkletFunction(argumentToWorkletize, state);\n  });\n}\n", "import type { NodePath } from '@babel/core';\nimport { isBlockStatement, isDirectiveLiteral } from '@babel/types';\nimport type { BlockStatement } from '@babel/types';\nimport { processIfWorkletFunction } from './processIfWorkletFunction';\nimport type { ExplicitWorklet, ReanimatedPluginPass } from './types';\n\nfunction hasWorkletDirective(directives: BlockStatement['directives']) {\n  return (\n    directives &&\n    directives.length > 0 &&\n    directives.some(\n      (directive) =>\n        isDirectiveLiteral(directive.value) &&\n        directive.value.value === 'worklet'\n    )\n  );\n}\n\nexport function processIfWorkletNode(\n  fun: NodePath<ExplicitWorklet>,\n  state: ReanimatedPluginPass\n) {\n  let shouldBeProcessed = false;\n  fun.traverse({\n    DirectiveLiteral(path) {\n      const value = path.node.value;\n      if (value === 'worklet' && isBlockStatement(fun.node.body)) {\n        const parent = path.getFunctionParent();\n        if (parent === fun) {\n          // make sure \"worklet\" is listed among directives for the fun\n          // this is necessary as because of some bug, babel will attempt to\n          // process replaced function if it is nested inside another function\n          const directives = fun.node.body.directives;\n\n          shouldBeProcessed = hasWorkletDirective(directives);\n        } else if (\n          state.opts.processNestedWorklets &&\n          // use better function for that once proper merges come to life\n          (parent?.isFunctionDeclaration() ||\n            parent?.isFunctionExpression() ||\n            parent?.isArrowFunctionExpression())\n        ) {\n          processIfWorkletNode(parent, state);\n        }\n      }\n    },\n  });\n\n  if (shouldBeProcessed) {\n    processIfWorkletFunction(fun, state);\n  }\n}\n", "import type { NodePath } from '@babel/core';\nimport type {\n  MemberExpression,\n  ObjectExpression,\n  JSXAttribute,\n  ObjectProperty,\n} from '@babel/types';\nimport {\n  callExpression,\n  arrowFunctionExpression,\n  isArrayExpression,\n  isJSXExpressionContainer,\n  identifier,\n  stringLiteral,\n  expressionStatement,\n  memberExpression,\n  returnStatement,\n  blockStatement,\n  isIdentifier,\n} from '@babel/types';\nimport { isRelease } from './utils';\nimport type { ReanimatedPluginPass } from './types';\nimport { strict as assert } from 'assert';\n\nfunction generateInlineStylesWarning(path: NodePath<MemberExpression>) {\n  // replaces `sharedvalue.value` with `(()=>{console.warn(require('react-native-reanimated').getUseOfValueInStyleWarning());return sharedvalue.value;})()`\n  return callExpression(\n    arrowFunctionExpression(\n      [],\n      blockStatement([\n        expressionStatement(\n          callExpression(\n            memberExpression(identifier('console'), identifier('warn')),\n            [\n              callExpression(\n                memberExpression(\n                  callExpression(identifier('require'), [\n                    stringLiteral('react-native-reanimated'),\n                  ]),\n                  identifier('getUseOfValueInStyleWarning')\n                ),\n                []\n              ),\n            ]\n          )\n        ),\n        returnStatement(path.node),\n      ])\n    ),\n    []\n  );\n}\n\nfunction processPropertyValueForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n) {\n  // if it's something like object.value then raise a warning\n  if (path.isMemberExpression() && isIdentifier(path.node.property)) {\n    if (path.node.property.name === 'value') {\n      path.replaceWith(generateInlineStylesWarning(path));\n    }\n  }\n}\n\nfunction processTransformPropertyForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n) {\n  if (isArrayExpression(path.node)) {\n    const elements = path.get('elements');\n    assert(\n      Array.isArray(elements),\n      '[Reanimated] `elements` should be an array.'\n    );\n    for (const element of elements) {\n      if (element.isObjectExpression()) {\n        processStyleObjectForInlineStylesWarning(element);\n      }\n    }\n  }\n}\n\nfunction processStyleObjectForInlineStylesWarning(\n  path: NodePath<ObjectExpression>\n) {\n  const properties = path.get('properties');\n  for (const property of properties) {\n    if (property.isObjectProperty()) {\n      const value = property.get('value');\n      if (\n        isIdentifier(property.node.key) &&\n        property.node.key.name === 'transform'\n      ) {\n        processTransformPropertyForInlineStylesWarning(value);\n      } else {\n        processPropertyValueForInlineStylesWarning(value);\n      }\n    }\n  }\n}\n\nexport function processInlineStylesWarning(\n  path: NodePath<JSXAttribute>,\n  state: ReanimatedPluginPass\n) {\n  if (isRelease()) {\n    return;\n  }\n  if (state.opts.disableInlineStylesWarning) {\n    return;\n  }\n  if (path.node.name.name !== 'style') {\n    return;\n  }\n  if (!isJSXExpressionContainer(path.node.value)) {\n    return;\n  }\n\n  const expression = path.get('value').get('expression');\n  // style={[{...}, {...}]}\n  assert(\n    !Array.isArray(expression),\n    '[Reanimated] `expression` should not be an array.'\n  );\n  if (expression.isArrayExpression()) {\n    const elements = expression.get('elements');\n    assert(\n      Array.isArray(elements),\n      '[Reanimated] `elements` should be an array.'\n    );\n    for (const element of elements) {\n      if (element.isObjectExpression()) {\n        processStyleObjectForInlineStylesWarning(element);\n      }\n    }\n  }\n  // style={{...}}\n  else if (expression.isObjectExpression()) {\n    processStyleObjectForInlineStylesWarning(expression);\n  }\n}\n", "import type { NodePath } from '@babel/core';\nimport type { Expression } from '@babel/types';\nimport {\n  isIdentifier,\n  isCallExpression,\n  isMemberExpression,\n  isExpression,\n} from '@babel/types';\nimport type { ExplicitWorklet } from './types';\n\nconst gestureHandlerGestureObjects = new Set([\n  'Tap',\n  'Pan',\n  'Pinch',\n  'Rotation',\n  'Fling',\n  'LongPress',\n  'ForceTouch',\n  'Native',\n  'Manual',\n  'Race',\n  'Simultaneous',\n  'Exclusive',\n  'Hover',\n]);\n\nconst gestureHandlerBuilderMethods = new Set([\n  'onBegin',\n  'onStart',\n  'onEnd',\n  'onFinalize',\n  'onUpdate',\n  'onChange',\n  'onTouchesDown',\n  'onTouchesMove',\n  'onTouchesUp',\n  'onTouchesCancelled',\n]);\n\n// Auto-workletizes React Native Gesture Handler callback functions.\n// Detects `Gesture.Tap().onEnd(<fun>)` or similar, but skips `something.onEnd(<fun>)`.\n// Supports method chaining as well, e.g. `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`.\n\n// Example #1: `Gesture.Tap().onEnd(<fun>)`\n/*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: Identifier('Gesture')\n          property: Identifier('Tap')\n        )\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun]\n  )\n  */\n\n// Example #2: `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`\n/*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: CallExpression(\n            callee: MemberExpression(\n              object: CallExpression(\n                callee: MemberExpression(\n                  object: Identifier('Gesture')\n                  property: Identifier('Tap')\n                )\n              )\n              property: Identifier('onStart')\n            )\n            arguments: [fun1]\n          )\n          property: Identifier('onUpdate')\n        )\n        arguments: [fun2]\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun3]\n  )\n  */\nexport function isGestureHandlerEventCallback(path: NodePath<ExplicitWorklet>) {\n  return (\n    isCallExpression(path.parent) &&\n    isExpression(path.parent.callee) &&\n    isGestureObjectEventCallbackMethod(path.parent.callee)\n  );\n}\n\nfunction isGestureObjectEventCallbackMethod(exp: Expression) {\n  // Checks if node matches the pattern `Gesture.Foo()[*].onBar`\n  // where `[*]` represents any number of method calls.\n  return (\n    isMemberExpression(exp) &&\n    isIdentifier(exp.property) &&\n    gestureHandlerBuilderMethods.has(exp.property.name) &&\n    containsGestureObject(exp.object)\n  );\n}\n\nfunction containsGestureObject(exp: Expression) {\n  // Checks if node matches the pattern `Gesture.Foo()[*]`\n  // where `[*]` represents any number of chained method calls, like `.something(42)`.\n\n  // direct call\n  if (isGestureObject(exp)) {\n    return true;\n  }\n\n  // method chaining\n  if (\n    isCallExpression(exp) &&\n    isMemberExpression(exp.callee) &&\n    containsGestureObject(exp.callee.object)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isGestureObject(exp: Expression) {\n  // Checks if node matches `Gesture.Tap()` or similar.\n  /*\n  node: CallExpression(\n    callee: MemberExpression(\n      object: Identifier('Gesture')\n      property: Identifier('Tap')\n    )\n  )\n  */\n  return (\n    isCallExpression(exp) &&\n    isMemberExpression(exp.callee) &&\n    isIdentifier(exp.callee.object) &&\n    exp.callee.object.name === 'Gesture' &&\n    isIdentifier(exp.callee.property) &&\n    gestureHandlerGestureObjects.has(exp.callee.property.name)\n  );\n}\n", "import type { NodePath } from '@babel/core';\nimport type {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  Expression,\n} from '@babel/types';\nimport {\n  isIdentifier,\n  isCallExpression,\n  isMemberExpression,\n  isExpression,\n  isNewExpression,\n} from '@babel/types';\n\nconst EntryExitAnimations = new Set([\n  'BounceIn',\n  'BounceInDown',\n  'BounceInLeft',\n  'BounceInRight',\n  'BounceInUp',\n  'BounceOut',\n  'BounceOutDown',\n  'BounceOutLeft',\n  'BounceOutRight',\n  'BounceOutUp',\n  'FadeIn',\n  'FadeInDown',\n  'FadeInLeft',\n  'FadeInRight',\n  'FadeInUp',\n  'FadeOut',\n  'FadeOutDown',\n  'FadeOutLeft',\n  'FadeOutRight',\n  'FadeOutUp',\n  'FlipInEasyX',\n  'FlipInEasyY',\n  'FlipInXDown',\n  'FlipInXUp',\n  'FlipInYLeft',\n  'FlipInYRight',\n  'FlipOutEasyX',\n  'FlipOutEasyY',\n  'FlipOutXDown',\n  'FlipOutXUp',\n  'FlipOutYLeft',\n  'FlipOutYRight',\n  'LightSpeedInLeft',\n  'LightSpeedInRight',\n  'LightSpeedOutLeft',\n  'LightSpeedOutRight',\n  'PinwheelIn',\n  'PinwheelOut',\n  'RollInLeft',\n  'RollInRight',\n  'RollOutLeft',\n  'RollOutRight',\n  'RotateInDownLeft',\n  'RotateInDownRight',\n  'RotateInUpLeft',\n  'RotateInUpRight',\n  'RotateOutDownLeft',\n  'RotateOutDownRight',\n  'RotateOutUpLeft',\n  'RotateOutUpRight',\n  'SlideInDown',\n  'SlideInLeft',\n  'SlideInRight',\n  'SlideInUp',\n  'SlideOutDown',\n  'SlideOutLeft',\n  'SlideOutRight',\n  'SlideOutUp',\n  'StretchInX',\n  'StretchInY',\n  'StretchOutX',\n  'StretchOutY',\n  'ZoomIn',\n  'ZoomInDown',\n  'ZoomInEasyDown',\n  'ZoomInEasyUp',\n  'ZoomInLeft',\n  'ZoomInRight',\n  'ZoomInRotate',\n  'ZoomInUp',\n  'ZoomOut',\n  'ZoomOutDown',\n  'ZoomOutEasyDown',\n  'ZoomOutEasyUp',\n  'ZoomOutLeft',\n  'ZoomOutRight',\n  'ZoomOutRotate',\n  'ZoomOutUp',\n]);\n\nconst LayoutTransitions = new Set([\n  'Layout',\n  'LinearTransition',\n  'SequencedTransition',\n  'FadingTransition',\n  'JumpingTransition',\n  'CurvedTransition',\n  'EntryExitTransition',\n]);\n\nconst LayoutAnimations = new Set([\n  ...EntryExitAnimations,\n  ...LayoutTransitions,\n]);\n\nconst BaseAnimationsChainableMethods = new Set([\n  'build',\n  'duration',\n  'delay',\n  'getDuration',\n  'randomDelay',\n  'getDelay',\n  'getDelayFunction',\n]);\n\nconst ComplexAnimationsChainableMethods = new Set([\n  'easing',\n  'rotate',\n  'springify',\n  'damping',\n  'mass',\n  'stiffness',\n  'overshootClamping',\n  'restDisplacementThreshold',\n  'restSpeedThreshold',\n  'withInitialValues',\n  'getAnimationAndConfig',\n]);\n\nconst DefaultTransitionChainableMethods = new Set([\n  'easingX',\n  'easingY',\n  'easingWidth',\n  'easingHeight',\n  'entering',\n  'exiting',\n  'reverse',\n]);\n\nconst LayoutAnimationsChainableMethods = new Set([\n  ...BaseAnimationsChainableMethods,\n  ...ComplexAnimationsChainableMethods,\n  ...DefaultTransitionChainableMethods,\n]);\n\nconst LayoutAnimationsCallbacks = new Set(['withCallback']);\n\nexport function isLayoutAnimationCallback(\n  path: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >\n) {\n  return (\n    isCallExpression(path.parent) &&\n    isExpression(path.parent.callee) &&\n    isLayoutAnimationCallbackMethod(path.parent.callee)\n  );\n}\n\nfunction isLayoutAnimationCallbackMethod(exp: Expression) {\n  return (\n    isMemberExpression(exp) &&\n    isIdentifier(exp.property) &&\n    LayoutAnimationsCallbacks.has(exp.property.name) &&\n    isLayoutAnimationsChainableOrNewOperator(exp.object)\n  );\n}\n\nfunction isLayoutAnimationsChainableOrNewOperator(exp: Expression) {\n  if (isIdentifier(exp) && LayoutAnimations.has(exp.name)) {\n    return true;\n  } else if (\n    isNewExpression(exp) &&\n    isIdentifier(exp.callee) &&\n    LayoutAnimations.has(exp.callee.name)\n  ) {\n    return true;\n  }\n  if (\n    isCallExpression(exp) &&\n    isMemberExpression(exp.callee) &&\n    isIdentifier(exp.callee.property) &&\n    LayoutAnimationsChainableMethods.has(exp.callee.property.name) &&\n    isLayoutAnimationsChainableOrNewOperator(exp.callee.object)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n", "import type { NodePath } from '@babel/core';\nimport { isGestureHandlerEventCallback } from './isGestureHandlerEventCallback';\nimport { processIfWorkletFunction } from './processIfWorkletFunction';\nimport { isLayoutAnimationCallback } from './isLayoutAnimationCallback';\nimport type { ExplicitWorklet, ReanimatedPluginPass } from './types';\n\nexport function processIfCallback(\n  path: NodePath<ExplicitWorklet>,\n  state: ReanimatedPluginPass\n) {\n  if (isGestureHandlerEventCallback(path) || isLayoutAnimationCallback(path)) {\n    processIfWorkletFunction(path, state);\n  }\n}\n", "import { globals } from './globals';\nimport type { ReanimatedPluginPass } from './types';\n\n/**\n * This function allows to add custom globals such as host-functions.\n * Those globals have to be passed as an argument for the plugin in babel.config.js.\n *\n * For example: `plugins: [['react-native-reanimated/plugin', { globals: ['myHostFunction'] }]]`\n */\nexport function addCustomGlobals(this: ReanimatedPluginPass) {\n  if (this.opts && Array.isArray(this.opts.globals)) {\n    this.opts.globals.forEach((name: string) => {\n      globals.add(name);\n    });\n  }\n}\n", "import type { PluginItem, NodePath } from '@babel/core';\nimport type { CallExpression } from '@babel/types';\nimport { processForCalleesWorklets } from './processForCalleesWorklets';\nimport type { ExplicitWorklet, ReanimatedPluginPass } from './types';\nimport { processIfWorkletNode } from './processIfWorkletNode';\nimport { processInlineStylesWarning } from './processInlineStylesWarning';\nimport { processIfCallback } from './processIfCallback';\nimport { addCustomGlobals } from './addCustomGlobals';\nimport { initializeGlobals } from './globals';\n\nmodule.exports = function (): PluginItem {\n  function runWithTaggedExceptions(fun: () => void) {\n    try {\n      fun();\n    } catch (e) {\n      throw new Error('[Reanimated] Babel plugin exception: ' + e);\n    }\n  }\n\n  return {\n    pre() {\n      runWithTaggedExceptions(() => {\n        initializeGlobals();\n        addCustomGlobals.call(this);\n      });\n    },\n    visitor: {\n      CallExpression: {\n        enter(path: NodePath<CallExpression>, state: ReanimatedPluginPass) {\n          runWithTaggedExceptions(() => processForCalleesWorklets(path, state));\n        },\n      },\n      'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression': {\n        enter(path: NodePath<ExplicitWorklet>, state: ReanimatedPluginPass) {\n          runWithTaggedExceptions(() => {\n            processIfWorkletNode(path, state);\n            processIfCallback(path, state);\n          });\n        },\n      },\n      JSXAttribute: {\n        enter(path, state) {\n          runWithTaggedExceptions(() =>\n            processInlineStylesWarning(path, state)\n          );\n        },\n      },\n    },\n  };\n};\n"],
  "mappings": "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MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;KACD;AAED,QAAM,oBAAoB,oBAAI,IAAI;MAChC;MACA;MACA;MACA;MACA;MACA;MACA;KACD;AAED,QAAM,mBAAmB,oBAAI,IAAI;MAC/B,GAAG;MACH,GAAG;KACJ;AAED,QAAM,iCAAiC,oBAAI,IAAI;MAC7C;MACA;MACA;MACA;MACA;MACA;MACA;KACD;AAED,QAAM,oCAAoC,oBAAI,IAAI;MAChD;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;KACD;AAED,QAAM,oCAAoC,oBAAI,IAAI;MAChD;MACA;MACA;MACA;MACA;MACA;MACA;KACD;AAED,QAAM,mCAAmC,oBAAI,IAAI;MAC/C,GAAG;MACH,GAAG;MACH,GAAG;KACJ;AAED,QAAM,4BAA4B,oBAAI,IAAI,CAAC,cAAc,CAAC;AAE1D,aAAgB,0BACd,MAEC;AAED,cACE,GAAA,QAAA,kBAAiB,KAAK,MAAM,MAC5B,GAAA,QAAA,cAAa,KAAK,OAAO,MAAM,KAC/B,gCAAgC,KAAK,OAAO,MAAM;IAEtD;AAVA,IAAAC,SAAA,4BAAA;AAYA,aAAS,gCAAgC,KAAe;AACtD,cACE,GAAA,QAAA,oBAAmB,GAAG,MACtB,GAAA,QAAA,cAAa,IAAI,QAAQ,KACzB,0BAA0B,IAAI,IAAI,SAAS,IAAI,KAC/C,yCAAyC,IAAI,MAAM;IAEvD;AAEA,aAAS,yCAAyC,KAAe;AAC/D,WAAI,GAAA,QAAA,cAAa,GAAG,KAAK,iBAAiB,IAAI,IAAI,IAAI,GAAG;AACvD,eAAO;kBAEP,GAAA,QAAA,iBAAgB,GAAG,MACnB,GAAA,QAAA,cAAa,IAAI,MAAM,KACvB,iBAAiB,IAAI,IAAI,OAAO,IAAI,GACpC;AACA,eAAO;;AAET,WACE,GAAA,QAAA,kBAAiB,GAAG,MACpB,GAAA,QAAA,oBAAmB,IAAI,MAAM,MAC7B,GAAA,QAAA,cAAa,IAAI,OAAO,QAAQ,KAChC,iCAAiC,IAAI,IAAI,OAAO,SAAS,IAAI,KAC7D,yCAAyC,IAAI,OAAO,MAAM,GAC1D;AACA,eAAO;;AAGT,aAAO;IACT;;;;;;;;;;AClMA,QAAA,kCAAA;AACA,QAAA,6BAAA;AACA,QAAA,8BAAA;AAGA,aAAgB,kBACd,MACA,OAA2B;AAE3B,WAAI,GAAA,gCAAA,+BAA8B,IAAI,MAAK,GAAA,4BAAA,2BAA0B,IAAI,GAAG;AAC1E,SAAA,GAAA,2BAAA,0BAAyB,MAAM,KAAK;;IAExC;AAPA,IAAAC,SAAA,oBAAA;;;;;;;;;;ACNA,QAAAC,aAAA;AASA,aAAgB,mBAAgB;AAC9B,UAAI,KAAK,QAAQ,MAAM,QAAQ,KAAK,KAAK,OAAO,GAAG;AACjD,aAAK,KAAK,QAAQ,QAAQ,CAAC,SAAgB;AACzC,UAAAA,WAAA,QAAQ,IAAI,IAAI;QAClB,CAAC;;IAEL;AANA,IAAAC,SAAA,mBAAA;;;;;;ACPA,IAAA,8BAAA;AAEA,IAAA,yBAAA;AACA,IAAA,+BAAA;AACA,IAAA,sBAAA;AACA,IAAA,qBAAA;AACA,IAAA,YAAA;AAEA,OAAO,UAAU,WAAA;AACf,WAAS,wBAAwB,KAAe;AAC9C,QAAI;AACF,UAAG;aACI,GAAP;AACA,YAAM,IAAI,MAAM,0CAA0C,CAAC;;EAE/D;AAEA,SAAO;IACL,MAAG;AACD,8BAAwB,MAAK;AAC3B,SAAA,GAAA,UAAA,mBAAiB;AACjB,2BAAA,iBAAiB,KAAK,IAAI;MAC5B,CAAC;IACH;IACA,SAAS;MACP,gBAAgB;QACd,MAAM,MAAgC,OAA2B;AAC/D,kCAAwB,OAAM,GAAA,4BAAA,2BAA0B,MAAM,KAAK,CAAC;QACtE;;MAEF,kEAAkE;QAChE,MAAM,MAAiC,OAA2B;AAChE,kCAAwB,MAAK;AAC3B,aAAA,GAAA,uBAAA,sBAAqB,MAAM,KAAK;AAChC,aAAA,GAAA,oBAAA,mBAAkB,MAAM,KAAK;UAC/B,CAAC;QACH;;MAEF,cAAc;QACZ,MAAM,MAAM,OAAK;AACf,kCAAwB,OACtB,GAAA,6BAAA,4BAA2B,MAAM,KAAK,CAAC;QAE3C;;;;AAIR;",
  "names": ["exports", "exports", "exports", "globals_1", "exports", "exports", "exports", "exports", "exports", "exports", "exports", "exports", "exports", "globals_1", "exports"]
}
