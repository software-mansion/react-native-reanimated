"use strict";(self.webpackChunkdocs_reanimated=self.webpackChunkdocs_reanimated||[]).push([[2739],{28453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>r});var a=t(96540);const i={},s=a.createContext(i);function o(n){const e=a.useContext(s);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),a.createElement(s.Provider,{value:e},n.children)}},76821:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"declarative","title":"Declarative Animation API","description":"Invoking animation differs from the way it is done when using the original Animated API.","source":"@site/versioned_docs/version-1.x/declarative.md","sourceDirName":".","slug":"/declarative","permalink":"/react-native-reanimated/docs/1.x/declarative","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-reanimated/edit/main/packages/docs-reanimated/versioned_docs/version-1.x/declarative.md","tags":[],"version":"1.x","frontMatter":{"id":"declarative","title":"Declarative Animation API","sidebar_label":"Declarative Animation API"},"sidebar":"docs","previous":{"title":"Getting started","permalink":"/react-native-reanimated/docs/1.x/getting_started"},"next":{"title":"Examples","permalink":"/react-native-reanimated/docs/1.x/examples"}}');var i=t(74848),s=t(28453);const o={id:"declarative",title:"Declarative Animation API",sidebar_label:"Declarative Animation API"},r=void 0,c={},d=[{value:"Backward compatible API",id:"backward-compatible-api",level:2}];function l(n){const e={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.p,{children:["Invoking animation differs from the way it is done when using the original ",(0,i.jsx)(e.code,{children:"Animated"})," API.\nHere, instead of having animation objects we operate on nodes that can perform single animation steps.\nIn order to map an animation into a value, we will make the value to be assigned to a node that among few other things will call into the animation step node. Check ",(0,i.jsx)(e.a,{href:"/react-native-reanimated/docs/1.x/animations/timing",children:(0,i.jsx)(e.code,{children:"timing"})}),", ",(0,i.jsx)(e.a,{href:"/react-native-reanimated/docs/1.x/animations/decay",children:(0,i.jsx)(e.code,{children:"decay"})})," and ",(0,i.jsx)(e.a,{href:"/react-native-reanimated/docs/1.x/animations/spring",children:(0,i.jsx)(e.code,{children:"spring"})})," nodes documentation for some details about how animation step nodes can be configured."]}),"\n",(0,i.jsx)(e.p,{children:"The example below shows a component that renders:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"import Animated, { Easing } from 'react-native-reanimated';\n\nconst {\n  Clock,\n  Value,\n  set,\n  cond,\n  startClock,\n  clockRunning,\n  timing,\n  debug,\n  stopClock,\n  block,\n} = Animated;\n\nfunction runTiming(clock, value, dest) {\n  const state = {\n    finished: new Value(0),\n    position: new Value(0),\n    time: new Value(0),\n    frameTime: new Value(0),\n  };\n\n  const config = {\n    duration: 5000,\n    toValue: new Value(0),\n    easing: Easing.inOut(Easing.ease),\n  };\n\n  return block([\n    cond(\n      clockRunning(clock),\n      [\n        // if the clock is already running we update the toValue, in case a new dest has been passed in\n        set(config.toValue, dest),\n      ],\n      [\n        // if the clock isn't running we reset all the animation params and start the clock\n        set(state.finished, 0),\n        set(state.time, 0),\n        set(state.position, value),\n        set(state.frameTime, 0),\n        set(config.toValue, dest),\n        startClock(clock),\n      ]\n    ),\n    // we run the step here that is going to update position\n    timing(clock, state, config),\n    // if the animation is over we stop the clock\n    cond(state.finished, debug('stop clock', stopClock(clock))),\n    // we made the block return the updated position\n    state.position,\n  ]);\n}\n\nexport class AnimatedBox extends Component {\n  // we create a clock node\n  clock = new Clock();\n  // and use runTiming method defined above to create a node that is going to be mapped\n  // to the translateX transform.\n  transX = runTiming(this.clock, -120, 120);\n\n  render() {\n    return (\n      <View style={styles.container}>\n        <Animated.View\n          style={[styles.box, { transform: [{ translateX: this.transX }] }]}\n        />\n      </View>\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"backward-compatible-api",children:"Backward compatible API"}),"\n",(0,i.jsxs)(e.p,{children:["As it might sometimes be impractical to use the API above, there's an alternative way of invoking animation, which is similar to the original ",(0,i.jsx)(e.code,{children:"Animated"})," API."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:'class Example extends Component {\n  constructor(props) {\n    super(props);\n    this._transX = new Value(0);\n    this._config = {\n      duration: 5000,\n      toValue: 120,\n      easing: Easing.inOut(Easing.ease),\n    };\n    this._anim = timing(this._transX, this._config);\n  }\n\n  render() {\n    return (\n      <View style={styles.container}>\n        <Animated.View\n          style={[styles.box, { transform: [{ translateX: this._transX }] }]}\n        />\n        <Button\n          onPress={() => {\n            this._anim.start();\n          }}\n          title="Start"\n        />\n      </View>\n    );\n  }\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:["This API gives the possibility to use animation with original ",(0,i.jsx)(e.code,{children:"Animated"})," API. It's also a way of running animation on some interaction without necessity or rerendering view."]})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}}}]);