"use strict";(self.webpackChunkdocs_reanimated=self.webpackChunkdocs_reanimated||[]).push([[4699],{28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>c});var r=i(96540);const s={},o=r.createContext(s);function t(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(o.Provider,{value:n},e.children)}},70812:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"api/hooks/useAnimatedSensor","title":"useAnimatedSensor","description":"useAnimatedSensor is available since v2.5.0","source":"@site/versioned_docs/version-2.x/api/hooks/useAnimatedSensor.md","sourceDirName":"api/hooks","slug":"/api/hooks/useAnimatedSensor","permalink":"/react-native-reanimated/docs/2.x/api/hooks/useAnimatedSensor","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-reanimated/edit/main/packages/docs-reanimated/versioned_docs/version-2.x/api/hooks/useAnimatedSensor.md","tags":[],"version":"2.x","frontMatter":{"id":"useAnimatedSensor","title":"useAnimatedSensor","sidebar_label":"useAnimatedSensor"},"sidebar":"docs","previous":{"title":"useAnimatedScrollHandler","permalink":"/react-native-reanimated/docs/2.x/api/hooks/useAnimatedScrollHandler"},"next":{"title":"useAnimatedStyle","permalink":"/react-native-reanimated/docs/2.x/api/hooks/useAnimatedStyle"}}');var s=i(74848),o=i(28453);const t={id:"useAnimatedSensor",title:"useAnimatedSensor",sidebar_label:"useAnimatedSensor"},c=void 0,d={},a=[{value:"Arguments",id:"arguments",level:3},{value:"<code>sensorType</code> - [SensorType]",id:"sensortype---sensortype",level:4},{value:"<code>config</code> - [UserConfig]",id:"config---userconfig",level:4},{value:"Returns",id:"returns",level:3},{value:"Types",id:"types",level:3},{value:"<code>AnimatedSensor: [object]</code>",id:"animatedsensor-object",level:4},{value:"<code>SensorType: [enum]</code>",id:"sensortype-enum",level:4},{value:"<code>UserConfig: [object]</code>",id:"userconfig-object",level:4},{value:"<code>IOSReferenceFrame: [enum]</code>",id:"iosreferenceframe-enum",level:4},{value:"<code>3DVector: [object]</code>",id:"3dvector-object",level:4},{value:"<code>RotationVector: [object]</code>",id:"rotationvector-object",level:4},{value:"<code>InterfaceOrientation: [enum]</code>",id:"interfaceorientation-enum",level:4},{value:"Example",id:"example",level:3},{value:"Live example",id:"live-example",level:3},{value:"Tips",id:"tips",level:3}];function l(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"useAnimatedSensor is available since v2.5.0"})}),"\n",(0,s.jsxs)(n.p,{children:["With the ",(0,s.jsx)(n.code,{children:"useAnimatedSensor"})," hook, you can easily create cool interactive animations based on data from sensors in the device such as gyroscope, accelerometer etc."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"useAnimatedSensor(sensorType: [SensorType], config?: [UserConfig]) -> [AnimatedSensor]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"arguments",children:"Arguments"}),"\n",(0,s.jsxs)(n.h4,{id:"sensortype---sensortype",children:[(0,s.jsx)(n.code,{children:"sensorType"})," - [",(0,s.jsx)(n.a,{href:"#sensortype-enum",children:"SensorType"}),"]"]}),"\n",(0,s.jsxs)(n.p,{children:["You can select the sensor available in [",(0,s.jsx)(n.a,{href:"#sensortype-enum",children:"SensorType"}),"] enum."]}),"\n",(0,s.jsxs)(n.h4,{id:"config---userconfig",children:[(0,s.jsx)(n.code,{children:"config"})," - [",(0,s.jsx)(n.a,{href:"#userconfig-object",children:"UserConfig"}),"]"]}),"\n",(0,s.jsx)(n.p,{children:"Optionally, you can pass configuration to customize the sensor behavior."}),"\n",(0,s.jsx)(n.h3,{id:"returns",children:"Returns"}),"\n",(0,s.jsxs)(n.p,{children:["Hook ",(0,s.jsx)(n.code,{children:"useAnimatedSensor"})," returns an instance of [",(0,s.jsx)(n.a,{href:"#animatedsensor-object",children:"AnimatedSensor"}),"];"]}),"\n",(0,s.jsx)(n.h3,{id:"types",children:"Types"}),"\n",(0,s.jsx)(n.h4,{id:"animatedsensor-object",children:(0,s.jsx)(n.code,{children:"AnimatedSensor: [object]"})}),"\n",(0,s.jsx)(n.p,{children:"Properties:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sensor"}),": [",(0,s.jsx)(n.a,{href:"/docs/2.x/api/hooks/useSharedValue",children:"SharedValue"}),"] contains [",(0,s.jsx)(n.a,{href:"#3dvector-object",children:"3DVector"}),"] or [",(0,s.jsx)(n.a,{href:"#rotationvector-object",children:"RotationVector"}),"] or ",(0,s.jsx)(n.code,{children:"null"}),(0,s.jsx)(n.br,{}),"\n","contains actual sensor measurements as a shared value"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"unregister: [function]"}),(0,s.jsx)(n.br,{}),"\n","allows you to stop listening to sensor updates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isAvailable: [boolean]"}),(0,s.jsx)(n.br,{}),"\n","the flag contains information on the availability of sensors in a device"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"config"}),": [",(0,s.jsx)(n.a,{href:"#userconfig-object",children:"UserConfig"}),"]",(0,s.jsx)(n.br,{}),"\n","the configuration provided by a user"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"sensortype-enum",children:(0,s.jsx)(n.code,{children:"SensorType: [enum]"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"SensorType"})," is an enum that contains possibly supported sensors.\nValues:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ACCELEROMETER"}),(0,s.jsx)(n.br,{}),"\n","measurements output as [",(0,s.jsx)(n.a,{href:"#3dvector-object",children:"3DVector"}),"]. Measured in m/s\xb2, excluding gravity."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"GYROSCOPE"}),(0,s.jsx)(n.br,{}),"\n","measurements output as [",(0,s.jsx)(n.a,{href:"#3dvector-object",children:"3DVector"}),"]. Measured in rad/s."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"GRAVITY"}),(0,s.jsx)(n.br,{}),"\n","measurements output as [",(0,s.jsx)(n.a,{href:"#3dvector-object",children:"3DVector"}),"]. Measured in m/s\xb2."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MAGNETIC_FIELD"}),(0,s.jsx)(n.br,{}),"\n","measurements output as [",(0,s.jsx)(n.a,{href:"#3dvector-object",children:"3DVector"}),"]. Measured in \u03bcT."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ROTATION"}),(0,s.jsx)(n.br,{}),"\n","measurements output as [",(0,s.jsx)(n.a,{href:"#rotationvector-object",children:"RotationVector"}),"]. [qx, qy, qz, qw] is a normalized quaternion. [yaw, pitch, roll] are rotations measured in radians along respective axes. We follow the iOS ",(0,s.jsx)(n.a,{href:"https://developer.apple.com/documentation/coremotion/getting_processed_device-motion_data#2870658",children:"convention"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"userconfig-object",children:(0,s.jsx)(n.code,{children:"UserConfig: [object]"})}),"\n",(0,s.jsx)(n.p,{children:"Properties:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"interval: [number | auto]"})," - interval in milliseconds between shared value updates. Pass ",(0,s.jsx)(n.code,{children:"'auto'"})," to select interval based on device frame rate. Default: ",(0,s.jsx)(n.code,{children:"'auto'"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"iosReferenceFrame: [[IOSReferenceFrame](#iosreferenceframe-enum)]"})," - reference frame to use on iOS. Default: ",(0,s.jsx)(n.code,{children:"Auto"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"adjustToInterfaceOrientation: [boolean]"})," - whether to adjust measurements to the current interface orientation. For example, in the landscape orientation axes x and y may need to be reversed when drawn on the screen. It's ",(0,s.jsx)(n.code,{children:"true"})," by default."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"iosreferenceframe-enum",children:(0,s.jsx)(n.code,{children:"IOSReferenceFrame: [enum]"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IOSReferenceFrame"})," is an enum describing reference frame to use on iOS. It follows Apple's ",(0,s.jsx)(n.a,{href:"https://developer.apple.com/documentation/coremotion/cmattitudereferenceframe",children:"documentation"}),". Possible values:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"XArbitraryZVertical"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"XArbitraryCorrectedZVertical"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"XMagneticNorthZVertical"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"XTrueNorthZVertical"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Auto"})," - on devices without magnetometer (for example iPods) ",(0,s.jsx)(n.code,{children:"XArbitraryZVertical"}),", on devices with magnetometer ",(0,s.jsx)(n.code,{children:"XArbitraryCorrectedZVertical"})]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"3dvector-object",children:(0,s.jsx)(n.code,{children:"3DVector: [object]"})}),"\n",(0,s.jsx)(n.p,{children:"Properties:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"x: number"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"y: number"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"z: number"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"interfaceOrientation: [[InterfaceOrientation](#interfaceorientation-enum)]"})}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"rotationvector-object",children:(0,s.jsx)(n.code,{children:"RotationVector: [object]"})}),"\n",(0,s.jsx)(n.p,{children:"Properties:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"qw: number"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"qx: number"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"qy: number"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"qz: number"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"yaw: number"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"pitch: number"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"roll: number"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"interfaceOrientation: [[InterfaceOrientation](#interfaceorientation-enum)]"})}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"interfaceorientation-enum",children:(0,s.jsx)(n.code,{children:"InterfaceOrientation: [enum]"})}),"\n",(0,s.jsx)(n.p,{children:"Values:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ROTATION_0"})," - default rotation on Android, portrait orientation on iOS"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ROTATION_90"})," - 90 degrees rotation on Android, landscape right orientation on iOS (landscape and home button on the right)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ROTATION_180"})," - 180 degrees rotation on Android, upside down orientation on iOS"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ROTATION_270"})," - 270 degrees rotation on Android, landscape left orientation on iOS (landscape and home button on the left)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function UseAnimatedSensorExample() {\n  const animatedSensor = useAnimatedSensor(SensorType.ROTATION, {\n    interval: 10,\n  }); // <- initialization\n  const style = useAnimatedStyle(() => {\n    const yaw = Math.abs(animatedSensor.sensor.value.yaw);\n    const pitch = Math.abs(animatedSensor.sensor.value.pitch);\n    return {\n      height: withTiming(yaw * 200 + 20, { duration: 100 }), // <- usage\n      width: withTiming(pitch * 200 + 20, { duration: 100 }), // <- usage\n    };\n  });\n\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Animated.View style={[{ backgroundColor: 'black' }, style]} />\n    </View>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"live-example",children:"Live example"}),"\n",(0,s.jsx)("video",{src:"https://user-images.githubusercontent.com/36106620/158634922-eaad656e-c837-44d5-8d51-8e7fa27c5a16.mp4",controls:"controls",muted:"muted",width:"400"}),"\n",(0,s.jsx)(n.h3,{id:"tips",children:"Tips"}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsxs)(n.p,{children:["On iOS, if you want to read sensor data you need to enable location services on your device (",(0,s.jsx)(n.code,{children:"Settings > Privacy > Location Services"}),")."]})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);