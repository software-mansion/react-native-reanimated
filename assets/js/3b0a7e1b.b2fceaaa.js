"use strict";(self.webpackChunkdocs_reanimated=self.webpackChunkdocs_reanimated||[]).push([[9228],{15454:(e,n,t)=>{t.d(n,{A:()=>a});var o=t(58343),r=t(72188);const a=()=>{const{colorScheme:e}=(0,o.Ut)();return"light"===e?l.darkText:l.lightText},l=r.A.create({lightText:{color:"var(--swm-off-white)"},darkText:{color:"var(--swm-navy-light-100)"}})},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var o=t(96540);const r={},a=o.createContext(r);function l(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),o.createElement(a.Provider,{value:n},e.children)}},41632:(e,n,t)=>{t.d(n,{A:()=>p});var o=t(55535),r=t(15782),a=t(9176),l=t(68444),s=t(72188),i=t(15454),c=t(74848);const d=o.default.createAnimatedComponent(r.A),u={code:"function UseHandlerEventExampleTsx1(event){const{offsetY}=this.__closure;offsetY.value=event.contentOffset.y;}"},h={code:"function UseHandlerEventExampleTsx2(event){const{handlers}=this.__closure;const{onScroll:onScroll}=handlers;if(onScroll){onScroll(event);}}"},f={code:'function UseHandlerEventExampleTsx3(){const{offsetY}=this.__closure;return{text:"Scroll offset: "+Math.round(offsetY.value)+"px",defaultValue:"Scroll offset: "+offsetY.value+"px"};}'};const p=function(){const e=(0,i.A)(),n=(0,o.useSharedValue)(0),t={onScroll:function(){const e=function(e){n.value=e.contentOffset.y};return e.__closure={offsetY:n},e.__workletHash=0x91a68d1fb11,e.__initData=u,e}()},{context:r,doDependenciesDiffer:s}=(0,o.useHandler)(t),p=(0,o.useEvent)(function(){const e=function(e){const{onScroll:n}=t;n&&n(e)};return e.__closure={handlers:t},e.__workletHash=0x9938ee7cde1,e.__initData=h,e}(),["onScroll"],s),m=(0,o.useAnimatedProps)(function(){const e=function(){return{text:`Scroll offset: ${Math.round(n.value)}px`,defaultValue:`Scroll offset: ${n.value}px`}};return e.__closure={offsetY:n},e.__workletHash=2714082481794,e.__initData=f,e}()),x=["#fa7f7c","#b58df1","#ffe780","#82cab2","#87cce8"].map(((e,n)=>(0,c.jsx)(a.A,{style:[v.section,{backgroundColor:e}]},n)));return(0,c.jsxs)(l.A,{style:v.container,children:[(0,c.jsx)(d,{animatedProps:m,editable:!1,style:[v.header,e]}),(0,c.jsx)(o.default.ScrollView,{onScroll:p,children:(0,c.jsx)(a.A,{style:v.container,children:x})})]})},v=s.A.create({container:{paddingHorizontal:32,height:350},header:{paddingVertical:16,paddingHorizontal:32,textAlign:"center",fontFamily:"Aeonik",marginTop:"-1px"},section:{height:150,borderRadius:20,marginVertical:10,marginHorizontal:20}})},52343:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>f,frontMatter:()=>i,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"advanced/useEvent","title":"useEvent","description":"useEvent is a low-level hook. It returns an event handler that will be called when a native event occurs. You can use it to create custom event handler hooks, like useScrollViewOffset or useAnimatedScrollHandler.","source":"@site/docs/advanced/useEvent.mdx","sourceDirName":"advanced","slug":"/advanced/useEvent","permalink":"/react-native-reanimated/docs/next/advanced/useEvent","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-reanimated/edit/main/packages/docs-reanimated/docs/advanced/useEvent.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"useFrameCallback","permalink":"/react-native-reanimated/docs/next/advanced/useFrameCallback"},"next":{"title":"useHandler","permalink":"/react-native-reanimated/docs/next/advanced/useHandler"}}');var r=t(74848),a=t(28453),l=t(41632),s=t(88907);const i={sidebar_position:4},c="useEvent",d={},u=[{value:"Reference",id:"reference",level:2},{value:"Arguments",id:"arguments",level:3},{value:"<code>handler</code>",id:"handler",level:4},{value:"<code>eventNames</code> <Optional></Optional>",id:"eventnames-",level:4},{value:"<code>rebuild</code> <Optional></Optional>",id:"rebuild-",level:4},{value:"Returns",id:"returns",level:3},{value:"Example",id:"example",level:2},{value:"Remarks",id:"remarks",level:2},{value:"Platform compatibility",id:"platform-compatibility",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components},{Details:t,InteractiveExample:o,Optional:i,PlatformCompatibility:c}=n;return t||p("Details",!0),o||p("InteractiveExample",!0),i||p("Optional",!0),c||p("PlatformCompatibility",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"useevent",children:"useEvent"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useEvent"})," is a low-level hook. It returns an event handler that will be called when a native event occurs. You can use it to create custom event handler hooks, like ",(0,r.jsx)(n.a,{href:"/docs/next/scroll/useScrollViewOffset/",children:(0,r.jsx)(n.code,{children:"useScrollViewOffset"})})," or ",(0,r.jsx)(n.a,{href:"/docs/next/scroll/useAnimatedScrollHandler/",children:(0,r.jsx)(n.code,{children:"useAnimatedScrollHandler"})}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { useEvent } from 'react-native-reanimated';\n\nfunction useAnimatedPagerScrollHandler(handlers, dependencies) {\n  const { context, doDependenciesDiffer } = useHandler(handlers, dependencies);\n\n  // highlight-start\n  return useEvent(\n    (event) => {\n      'worklet';\n      const { onPageScroll } = handlers;\n\n      if (onPageScroll && event.eventName.endsWith('onPageScroll')) {\n        onPageScroll(event, context);\n      }\n    },\n    ['onPageScroll'],\n    doDependenciesDiffer\n  );\n}\n// highlight-end\n\nreturn <Animated.View onScroll={useAnimatedPagerScrollHandler} />;\n"})}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Type definitions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function useEvent<\n  Event extends object,\n  Context extends Record<string, unknown> = never\n>(\n  handler: EventHandler<Event, Context>,\n  eventNames?: string[],\n  rebuild?: boolean\n): EventHandlerProcessed<Event, Context>;\n\ntype EventHandler<\n  Event extends object,\n  Context extends Record<string, unknown> = never\n> = (event: ReanimatedEvent<Event>, context?: Context) => void;\n\ntype EventHandlerProcessed<\n  Event extends object,\n  Context extends Record<string, unknown> = never\n> = (event: Event, context?: Context) => void;\n"})})]}),"\n",(0,r.jsx)(n.h3,{id:"arguments",children:"Arguments"}),"\n",(0,r.jsx)(n.h4,{id:"handler",children:(0,r.jsx)(n.code,{children:"handler"})}),"\n",(0,r.jsx)(n.p,{children:"Function that receives an event object with a native payload, which can be passed to the custom handler hook's worklets."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"event"})," - event object.\nThe payload can differ depending on the type of the event."]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"eventnames-",children:[(0,r.jsx)(n.code,{children:"eventNames"})," ",(0,r.jsx)(i,{})]}),"\n",(0,r.jsx)(n.p,{children:"Array of event names that will be handled by the handler."}),"\n",(0,r.jsxs)(n.h4,{id:"rebuild-",children:[(0,r.jsx)(n.code,{children:"rebuild"})," ",(0,r.jsx)(i,{})]}),"\n",(0,r.jsx)(n.p,{children:"Value indicating whether the handler should be rebuilt."}),"\n",(0,r.jsx)(n.h3,{id:"returns",children:"Returns"}),"\n",(0,r.jsx)(n.p,{children:"The hook returns an event handler that will be invoked when a native event is dispatched. That handler may be connected to multiple components and will be invoked for each one's specific events."}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n","\n",(0,r.jsx)(o,{src:s.A,component:l.A}),"\n",(0,r.jsxs)(n.p,{children:["This example can be more easily implemented using ",(0,r.jsx)(n.a,{href:"/docs/next/scroll/useScrollViewOffset/",children:(0,r.jsx)(n.code,{children:"useScrollViewOffset"})}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"remarks",children:"Remarks"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Keep in mind that not all scroll events are supported on the web, only ",(0,r.jsx)(n.code,{children:"onScroll"})," is available across browsers."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"platform-compatibility",children:"Platform compatibility"}),"\n",(0,r.jsx)(c,{android:!0,ios:!0,web:!0})]})}function f(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}function p(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},68444:(e,n,t)=>{t.d(n,{A:()=>f});var o=t(58168),r=t(98587),a=t(96540),l=t(72188),s=t(9176),i=t(7162),c=["style"],d=i.A&&window.CSS&&window.CSS.supports&&window.CSS.supports("top: constant(safe-area-inset-top)")?"constant":"env",u=a.forwardRef(((e,n)=>{var t=e.style,i=(0,r.A)(e,c);return a.createElement(s.A,(0,o.A)({},i,{ref:n,style:l.A.compose(h.root,t)}))}));u.displayName="SafeAreaView";var h=l.A.create({root:{paddingTop:d+"(safe-area-inset-top)",paddingRight:d+"(safe-area-inset-right)",paddingBottom:d+"(safe-area-inset-bottom)",paddingLeft:d+"(safe-area-inset-left)"}});const f=u},88907:(e,n,t)=>{t.d(n,{A:()=>o});const o="import React, { useEffect } from 'react';\nimport Animated, {\n  useHandler,\n  useEvent,\n  useSharedValue,\n  useAnimatedProps,\n  type ScrollEvent,\n} from 'react-native-reanimated';\nimport { TextInput, SafeAreaView, View, StyleSheet } from 'react-native';\nimport useThemedTextStyle from '@site/src/hooks/useThemedTextStyle';\n\nconst AnimatedTextInput = Animated.createAnimatedComponent(TextInput);\n\nfunction UseHandlerExample() {\n  const textColor = useThemedTextStyle();\n  const offsetY = useSharedValue(0);\n\n  const handlers = {\n    onScroll: (event: ScrollEvent) => {\n      'worklet';\n      offsetY.value = event.contentOffset.y;\n    },\n  };\n\n  const { context, doDependenciesDiffer } = useHandler(handlers);\n\n  const scrollHandler = useEvent(\n    (event: ScrollEvent) => {\n      'worklet';\n      const { onScroll } = handlers;\n      if (onScroll) {\n        onScroll(event);\n      }\n    },\n    ['onScroll'],\n    doDependenciesDiffer\n  );\n\n  const animatedProps = useAnimatedProps(() => {\n    return {\n      text: `Scroll offset: ${Math.round(offsetY.value)}px`,\n      defaultValue: `Scroll offset: ${offsetY.value}px`,\n    };\n  });\n\n  const BRAND_COLORS = ['#fa7f7c', '#b58df1', '#ffe780', '#82cab2', '#87cce8'];\n\n  const content = BRAND_COLORS.map((color, index) => (\n    <View\n      key={index}\n      style={[\n        styles.section,\n        {\n          backgroundColor: color,\n        },\n      ]}\n    />\n  ));\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <AnimatedTextInput\n        animatedProps={animatedProps}\n        editable={false}\n        style={[styles.header, textColor]}\n      />\n      <Animated.ScrollView onScroll={scrollHandler}>\n        <View style={styles.container}>{content}</View>\n      </Animated.ScrollView>\n    </SafeAreaView>\n  );\n}\n\nexport default UseHandlerExample;\n\nconst styles = StyleSheet.create({\n  container: {\n    paddingHorizontal: 32,\n    height: 350,\n  },\n  header: {\n    paddingVertical: 16,\n    paddingHorizontal: 32,\n    textAlign: 'center',\n    fontFamily: 'Aeonik',\n    marginTop: '-1px',\n  },\n  section: {\n    height: 150,\n    borderRadius: 20,\n    marginVertical: 10,\n    marginHorizontal: 20,\n  },\n});\n"}}]);