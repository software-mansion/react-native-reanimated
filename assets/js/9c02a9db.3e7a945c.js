"use strict";(self.webpackChunkdocs_reanimated=self.webpackChunkdocs_reanimated||[]).push([[1253],{12066:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/MetroConfigAfter-7c02a5a38ee254074b0d4b371a50c14d.png"},13586:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"debugging/accurate-call-stacks","title":"Accurate Call Stacks","description":"When debugging Reanimated code, you may encounter error or warning call stacks that don\'t clearly indicate the root cause of the problem. These stacks can be misleading, as they often highlight code from Reanimated\'s internals rather than the misuse of the Reanimated API that is the source of the problem.","source":"@site/versioned_docs/version-3.x/debugging/accurate-call-stacks.mdx","sourceDirName":"debugging","slug":"/debugging/accurate-call-stacks","permalink":"/react-native-reanimated/docs/debugging/accurate-call-stacks","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-reanimated/edit/main/packages/docs-reanimated/versioned_docs/version-3.x/debugging/accurate-call-stacks.mdx","tags":[],"version":"3.x","sidebarPosition":1,"frontMatter":{"id":"accurate-call-stacks","sidebar_label":"Accurate Call Stacks","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Debugging","permalink":"/react-native-reanimated/docs/category/debugging"},"next":{"title":"Logger configuration","permalink":"/react-native-reanimated/docs/debugging/logger-configuration"}}');var r=a(74848),s=a(28453);const i={id:"accurate-call-stacks",sidebar_label:"Accurate Call Stacks",sidebar_position:1},c="Accurate Call Stacks",o={},d=[{value:"Reference",id:"reference",level:2},{value:"Example",id:"example",level:2},{value:"Remarks",id:"remarks",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components},{Details:n,Indent:i}=t;return n||g("Details",!0),i||g("Indent",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"accurate-call-stacks",children:"Accurate Call Stacks"})}),"\n",(0,r.jsx)(t.p,{children:"When debugging Reanimated code, you may encounter error or warning call stacks that don't clearly indicate the root cause of the problem. These stacks can be misleading, as they often highlight code from Reanimated's internals rather than the misuse of the Reanimated API that is the source of the problem."}),"\n",(0,r.jsxs)(t.p,{children:["To address this, Reanimated provides a Metro configuration wrapper called ",(0,r.jsx)(t.code,{children:"wrapWithReanimatedMetroConfig"}),". This wrapper automatically adjusts your Metro config to improve the accuracy of call stacks in warnings and errors generated by the Reanimated library."]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"How does it work?"}),(0,r.jsx)(t.p,{children:"By default, React Native displays the entire call stack up to the point where an error is thrown or a warning is logged, including all stack frames except those from the React Native source code."}),(0,r.jsxs)(t.p,{children:["To modify this behavior, we can use the ",(0,r.jsx)(t.code,{children:"symbolicator"})," field in the Metro config, which allows customization of the displayed stack frames. Reanimated leverages this feature to adjust which stack frames are ",(0,r.jsx)(t.strong,{children:"hidden"})," (",(0,r.jsx)(t.strong,{children:"collapsed"}),") in the stack trace. By doing so, stack frames from Reanimated internals are hidden, ensuring that the stack trace only highlights the relevant parts of the call stack."]})]}),"\n",(0,r.jsx)(t.h2,{id:"reference",children:"Reference"}),"\n",(0,r.jsxs)(t.p,{children:["To enable more accurate call stacks, simply import ",(0,r.jsx)(t.code,{children:"wrapWithReanimatedMetroConfig"})," from ",(0,r.jsx)(t.code,{children:"react-native-reanimated/metro-config"})," and wrap your existing Metro configuration in the ",(0,r.jsx)(t.code,{children:"metro.config.js"})," file with it."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"// metro.config.js\nconst {\n  wrapWithReanimatedMetroConfig,\n} = require('react-native-reanimated/metro-config');\n\nconst config = {\n  // Your existing Metro configuration options\n};\n\nmodule.exports = wrapWithReanimatedMetroConfig(config);\n"})}),"\n",(0,r.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,r.jsxs)(t.p,{children:["The following example shows the difference in call stacks before and after applying the Reanimated Metro config wrapper. The ",(0,r.jsx)(t.strong,{children:"Before"})," image displays Reanimated source code as the error source, while the ",(0,r.jsx)(t.strong,{children:"After"})," image shows the actual incorrect code that caused the error."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Before"}),(0,r.jsx)(t.th,{children:"After"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.img,{alt:"Call Stack before applying Reanimated Metro config wrapper",src:a(37791).A+"",width:"1179",height:"2556"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.img,{alt:"Call Stack after applying Reanimated Metro config wrapper",src:a(12066).A+"",width:"1179",height:"2556"})})]})})]}),"\n",(0,r.jsx)(t.h2,{id:"remarks",children:"Remarks"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"wrapWithReanimatedMetroConfig"})," doesn't remove any stack frames from the call stack; it only collapses irrelevant frames from Reanimated. If you want to inspect them, you can expand collapsed stack frames by pressing on the ",(0,r.jsx)(t.strong,{children:"See N more frames"})," text at the bottom of the ",(0,r.jsx)(t.strong,{children:"Call Stack"}),"."]}),"\n"]}),"\n",(0,r.jsx)(i,{children:(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Collapsed"}),(0,r.jsx)(t.th,{children:"Expanded"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.img,{alt:"Collapsed Call Stack",src:a(49950).A+"",width:"1179",height:"2556"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.img,{alt:"Expanded Call Stack",src:a(42662).A+"",width:"1179",height:"2556"})})]})})]})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Some errors, particularly from asynchronous code, may still result in stack traces pointing to Reanimated internals instead of the exact problematic line in your code. This occurs because stack traces lose track of the original code that initiated the asynchronous operation. In such a case, you'll need to manually debug the issue based on the error message to identify the potential cause of the problem."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}function g(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>c});var n=a(96540);const r={},s=n.createContext(r);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(s.Provider,{value:t},e.children)}},37791:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/MetroConfigBefore-1461ad807236d9c4eb7ec7ddd594f3a2.png"},42662:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/ExpandedCallStack-8df96a3f5d5aaca1bb67c1f8374f0357.png"},49950:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/CollapsedCallStack-4537d87c45e9af7439a4dbd72daebf33.png"}}]);