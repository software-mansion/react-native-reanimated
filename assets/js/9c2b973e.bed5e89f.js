"use strict";(globalThis.webpackChunkdocs_reanimated=globalThis.webpackChunkdocs_reanimated||[]).push([[9139],{10966:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"guides/performance","title":"Performance","description":"This guide covers best practices and tips to achieve the best performance with Reanimated.","source":"@site/docs/guides/performance.md","sourceDirName":"guides","slug":"/guides/performance","permalink":"/react-native-reanimated/docs/guides/performance","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-reanimated/edit/main/docs/docs-reanimated/docs/guides/performance.md","tags":[],"version":"current","frontMatter":{"id":"performance","title":"Performance","sidebar_label":"Performance"},"sidebar":"tutorialSidebar","previous":{"title":"Migration from 3.x","permalink":"/react-native-reanimated/docs/guides/migration-from-3.x"},"next":{"title":"Supported style properties","permalink":"/react-native-reanimated/docs/guides/supported-properties"}}');var t=r(47671),a=r(30620);const o={id:"performance",title:"Performance",sidebar_label:"Performance"},s="Performance",l={},d=[{value:"Performance regressions on the New Architecture",id:"performance-regressions-on-the-new-architecture",level:2},{value:"\u26a0\ufe0f Flickering/jittering while scrolling",id:"\ufe0f-flickeringjittering-while-scrolling",level:3},{value:"\u26a0\ufe0f Lower FPS while scrolling",id:"\ufe0f-lower-fps-while-scrolling",level:3},{value:"\u26a0\ufe0f Low FPS when running multiple animations at once",id:"\ufe0f-low-fps-when-running-multiple-animations-at-once",level:3},{value:"\u2139\ufe0f Debug vs. release mode",id:"\u2139\ufe0f-debug-vs-release-mode",level:3},{value:"\ud83d\udca1 Use <code>debugOptimized</code> build variant on Android",id:"-use-debugoptimized-build-variant-on-android",level:4},{value:"What to avoid",id:"what-to-avoid",level:2},{value:"\u274c Avoid reading shared values on the JS thread",id:"-avoid-reading-shared-values-on-the-js-thread",level:3},{value:"\u274c Avoid animating too many components at once",id:"-avoid-animating-too-many-components-at-once",level:3},{value:"Other tips",id:"other-tips",level:2},{value:"\ud83d\udca1 Enable 120 fps",id:"-enable-120-fps",level:3},{value:"\ud83d\udca1 Prefer animating non-layout properties",id:"-prefer-animating-non-layout-properties",level:3},{value:"\ud83d\udca1 Memoize frame callbacks",id:"-memoize-frame-callbacks",level:3},{value:"\ud83d\udca1 Memoize gesture objects",id:"-memoize-gesture-objects",level:3},{value:"\ud83d\udca1 Animate <code>TextInput</code> instead of re-rendering <code>Text</code> component",id:"-animate-textinput-instead-of-re-rendering-text-component",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"performance",children:"Performance"})}),"\n",(0,t.jsx)(n.p,{children:"This guide covers best practices and tips to achieve the best performance with Reanimated."}),"\n",(0,t.jsx)(n.h2,{id:"performance-regressions-on-the-new-architecture",children:"Performance regressions on the New Architecture"}),"\n",(0,t.jsx)(n.p,{children:"After enabling the New Architecture in your app, you might notice some performance regressions of animations, especially when compared to the old architecture. This can also happen after upgrading to Expo SDK 53 (or newer) where the New Architecture is enabled by default."}),"\n",(0,t.jsx)(n.p,{children:"We are actively working with React core team at Meta on identifying bottlenecks and improving the overall state of animations on the New Architecture. For now, please consider enabling the following optimizations in your app to mitigate the performance regressions."}),"\n",(0,t.jsx)(n.h3,{id:"\ufe0f-flickeringjittering-while-scrolling",children:"\u26a0\ufe0f Flickering/jittering while scrolling"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," When scrolling a ",(0,t.jsx)(n.code,{children:"FlatList"})," or ",(0,t.jsx)(n.code,{children:"ScrollView"}),", you might notice flickering or jittering of animated components (e.g. sticky header) implemented using ",(0,t.jsx)(n.code,{children:"useAnimatedScrollHandler"})," hook."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution:"})," You need to upgrade to React Native 0.81 (or newer), set experimental release level in order to enable ",(0,t.jsx)(n.code,{children:"preventShadowTreeCommitExhaustion"})," feature flag and enable ",(0,t.jsx)(n.a,{href:"./feature-flags#disable_commit_pausing_mechanism",children:(0,t.jsx)(n.code,{children:"DISABLE_COMMIT_PAUSING_MECHANISM"})})," static feature flag as described ",(0,t.jsx)(n.a,{href:"./feature-flags#disable_commit_pausing_mechanism",children:"here"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"\ufe0f-lower-fps-while-scrolling",children:"\u26a0\ufe0f Lower FPS while scrolling"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Frames per seconds drops when there are many animated components on the screen during scrolling."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution:"})," You need to upgrade to React Native 0.80 (or newer), upgrade to Reanimated 4.2.0 (or newer) and enable ",(0,t.jsx)(n.a,{href:"./feature-flags#use_commit_hook_only_for_react_commits",children:(0,t.jsx)(n.code,{children:"USE_COMMIT_HOOK_ONLY_FOR_REACT_COMMITS"})})," static feature flag as described ",(0,t.jsx)(n.a,{href:"./feature-flags#use_commit_hook_only_for_react_commits",children:"here"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["You can also consider enabling ",(0,t.jsx)(n.code,{children:"enableCppPropsIteratorSetter"})," feature flag as described ",(0,t.jsx)(n.a,{href:"#%EF%B8%8F-low-fps-when-running-multiple-animations-at-once",children:"below"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"\ufe0f-low-fps-when-running-multiple-animations-at-once",children:"\u26a0\ufe0f Low FPS when running multiple animations at once"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," When animating many components simultaneously (also across multiple screens) you might notice FPS regressions."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution 1:"})," Enable static feature flags ",(0,t.jsx)(n.code,{children:"ANDROID_SYNCHRONOUSLY_UPDATE_UI_PROPS"})," (available from 4.0.0) and ",(0,t.jsx)(n.code,{children:"IOS_SYNCHRONOUSLY_UPDATE_UI_PROPS"})," (available from 4.2.0) as described ",(0,t.jsx)(n.a,{href:"./feature-flags#android_synchronously_update_ui_props",children:"here"})," for Android and ",(0,t.jsx)(n.a,{href:"./feature-flags#ios_synchronously_update_ui_props",children:"here"})," for iOS, respectively. This will enable a fast code path for applying updates of non-layout styles like ",(0,t.jsx)(n.code,{children:"opacity"})," or ",(0,t.jsx)(n.code,{children:"transform"})," via platform-specific mechanisms rather than cloning ",(0,t.jsx)(n.code,{children:"ShadowNode"})," instances and calling ",(0,t.jsx)(n.code,{children:"ShadowTree::commit"})," method."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that these flags affect the touch detection system for components with animated transforms so you might want to consider using ",(0,t.jsx)(n.code,{children:"Pressable"})," from ",(0,t.jsx)(n.code,{children:"react-native-gesture-handler"})," instead of the built-in one from ",(0,t.jsx)(n.code,{children:"react-native"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["It is also recommended to animate non-layout styles (e.g. ",(0,t.jsx)(n.code,{children:"transform"}),") rather than layout-affecting styles as described ",(0,t.jsx)(n.a,{href:"#-prefer-animating-non-layout-properties",children:"below"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution 2:"})," Manually enable ",(0,t.jsx)(n.code,{children:"enableCppPropsIteratorSetter"})," feature flag from ",(0,t.jsx)(n.code,{children:"react-native"})," by patching the source files and building React Native from source. Note that this feature flag is experimental and may produce unexpected results."]}),"\n",(0,t.jsx)(n.h3,{id:"\u2139\ufe0f-debug-vs-release-mode",children:"\u2139\ufe0f Debug vs. release mode"}),"\n",(0,t.jsx)(n.p,{children:"It is very likely that the performance regressions are noticeable only the development build of your app. In the release mode, both Reanimated and React Native itself are built with compiler optimizations enabled which results in much better performance when compared to the debug mode."}),"\n",(0,t.jsxs)(n.h4,{id:"-use-debugoptimized-build-variant-on-android",children:["\ud83d\udca1 Use ",(0,t.jsx)(n.code,{children:"debugOptimized"})," build variant on Android"]}),"\n",(0,t.jsxs)(n.p,{children:["For better development experience, you might also consider using ",(0,t.jsx)(n.code,{children:"debugOptimized"})," build variant on Android (available from React Native 0.82) \u2013 more details ",(0,t.jsx)(n.a,{href:"https://reactnative.dev/blog/2025/10/08/react-native-0.82#optimized-debug-build-type-for-android",children:"here"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"what-to-avoid",children:"What to avoid"}),"\n",(0,t.jsx)(n.h3,{id:"-avoid-reading-shared-values-on-the-js-thread",children:"\u274c Avoid reading shared values on the JS thread"}),"\n",(0,t.jsx)(n.p,{children:"Reading shared values is allowed only from worklets running on the UI thread. You should avoid reading shared values in the React Native runtime on the JavaScript thread."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const sv = useSharedValue(0);\n\nuseEffect(() => {\n  console.log(sv.value); // \u274c reading shared value in the RN runtime (not recommended)\n}, []);\n\nconst animatedStyle = useAnimatedStyle(() => {\n  return { opacity: sv.value }; // \u2705 this is okay\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When you read the ",(0,t.jsx)(n.code,{children:"sv.value"})," in the React Native runtime, the JS thread will get blocked until the value is fetched from the UI thread. In most cases it will be negligible, but if the UI thread is busy or you are reading a value multiple times, the wait time needed to synchronize both threads may significantly increase."]}),"\n",(0,t.jsx)(n.h3,{id:"-avoid-animating-too-many-components-at-once",children:"\u274c Avoid animating too many components at once"}),"\n",(0,t.jsxs)(n.p,{children:["Reanimated is perfectly capable of animating several dozens of components at once. However, if there's too many components to be animated simultaneously, performance can be affected. As a rule of thumb, you should animate no more than 100 components for low-end Android devices and no more than 500 components for iOS. For more complex animations, consider using Reanimated with ",(0,t.jsx)(n.code,{children:"react-native-skia"})," instead of rendering individual React components."]}),"\n",(0,t.jsx)(n.h2,{id:"other-tips",children:"Other tips"}),"\n",(0,t.jsx)(n.h3,{id:"-enable-120-fps",children:"\ud83d\udca1 Enable 120 fps"}),"\n",(0,t.jsxs)(n.p,{children:["In order to enable support for 120 fps on iOS, make sure that ",(0,t.jsx)(n.code,{children:"CADisableMinimumFrameDurationOnPhone"})," flag is enabled in ",(0,t.jsx)(n.code,{children:"Info.plist"}),". The flag is enabled by default in the app template starting from React Native 0.82."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<key>CADisableMinimumFrameDurationOnPhone</key>\n<true/>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"-prefer-animating-non-layout-properties",children:"\ud83d\udca1 Prefer animating non-layout properties"}),"\n",(0,t.jsxs)(n.p,{children:["Animating non-layout properties (like ",(0,t.jsx)(n.code,{children:"transform"}),", ",(0,t.jsx)(n.code,{children:"opacity"})," or ",(0,t.jsx)(n.code,{children:"backgroundColor"}),") is generally more performant than animating styles that affect layout (like ",(0,t.jsx)(n.code,{children:"top"}),"/",(0,t.jsx)(n.code,{children:"left"}),", ",(0,t.jsx)(n.code,{children:"width"}),"/",(0,t.jsx)(n.code,{children:"height"}),", ",(0,t.jsx)(n.code,{children:"margin"})," or ",(0,t.jsx)(n.code,{children:"padding"}),"). That's because the latter group requires an additional step of layout recalculation on each animation frame."]}),"\n",(0,t.jsxs)(n.p,{children:["Whenever possible, you should prefer using non-layout styles (e.g. ",(0,t.jsx)(n.code,{children:"transform"})," with ",(0,t.jsx)(n.code,{children:"translateX"}),"/",(0,t.jsx)(n.code,{children:"translateY"}),") rather than their layout-affecting counterparts (i.e. ",(0,t.jsx)(n.code,{children:"top"}),"/",(0,t.jsx)(n.code,{children:"left"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, non-layout properties can be updated using a fast path \u2013 more details ",(0,t.jsx)(n.a,{href:"./feature-flags#android_synchronously_update_ui_props",children:"here"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"-memoize-frame-callbacks",children:"\ud83d\udca1 Memoize frame callbacks"}),"\n",(0,t.jsxs)(n.p,{children:["If you're using ",(0,t.jsx)(n.a,{href:"../advanced/useFrameCallback",children:(0,t.jsx)(n.code,{children:"useFrameCallback"})}),", you should wrap the frame callback worklet inside ",(0,t.jsx)(n.code,{children:"useCallback"})," in order to memoize it. This way, the frame callback won't need to be recrated and thus registered on every render. If you're using React Compiler, the frame callback should be memoized automatically."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"useFrameCallback(\n  useCallback(() => {\n    'worklet';\n  }, [...deps])\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"-memoize-gesture-objects",children:"\ud83d\udca1 Memoize gesture objects"}),"\n",(0,t.jsxs)(n.p,{children:["If you're using ",(0,t.jsx)(n.a,{href:"https://docs.swmansion.com/react-native-gesture-handler/",children:"React Native Gesture Handler"}),", you should wrap gesture objects like ",(0,t.jsx)(n.code,{children:"Gesture.Tap()"})," or similar inside ",(0,t.jsx)(n.code,{children:"useMemo"})," in order to memoize them. This way, the gestures won't need to be reattached on every render. This is particularly important for ",(0,t.jsx)(n.code,{children:"FlatList"})," items where performance is key. If you're using React Compiler, the gesture objects should be memoized automatically."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"const pan = useMemo(\n  () =>\n    Gesture.Pan()\n      .onStart(() => {})\n      .onEnd(() => {}),\n  [...deps]\n);\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"-animate-textinput-instead-of-re-rendering-text-component",children:["\ud83d\udca1 Animate ",(0,t.jsx)(n.code,{children:"TextInput"})," instead of re-rendering ",(0,t.jsx)(n.code,{children:"Text"})," component"]}),"\n",(0,t.jsxs)(n.p,{children:["When implementing an animated number counter, don't use React state to periodically update the counter. Instead, store the number in a shared value and use an animated ",(0,t.jsx)(n.code,{children:"TextInput"})," component to display the current value. For more details, see ",(0,t.jsx)(n.a,{href:"https://github.com/software-mansion/react-native-reanimated/blob/main/apps/common-app/src/apps/reanimated/examples/CounterExample.tsx",children:"this example"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},30620:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var i=r(39471);const t={},a=i.createContext(t);function o(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);