"use strict";(self.webpackChunkdocs_reanimated=self.webpackChunkdocs_reanimated||[]).push([[9996],{20304:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"reanimated-babel-plugin/about","title":"About","description":"What is Reanimated Babel Plugin?","source":"@site/docs/reanimated-babel-plugin/about.md","sourceDirName":"reanimated-babel-plugin","slug":"/reanimated-babel-plugin/about","permalink":"/react-native-reanimated/docs/reanimated-babel-plugin/about","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-reanimated/edit/main/docs/docs-reanimated/docs/reanimated-babel-plugin/about.md","tags":[],"version":"current","frontMatter":{"id":"about","title":"About","sidebar_label":"About"},"sidebar":"tutorialSidebar","previous":{"title":"Reanimated Babel plugin","permalink":"/react-native-reanimated/docs/category/reanimated-babel-plugin"},"next":{"title":"Options","permalink":"/react-native-reanimated/docs/reanimated-babel-plugin/plugin-options"}}');var i=t(47671),s=t(30620);const l={id:"about",title:"About",sidebar_label:"About"},a="Reanimated Babel Plugin",r={},c=[{value:"What is Reanimated Babel Plugin?",id:"what-is-reanimated-babel-plugin",level:2},{value:"What can be a worklet?",id:"what-can-be-a-worklet",level:2},{value:"JavaScript terms",id:"javascript-terms",level:3},{value:"Function Declarations",id:"function-declarations",level:4},{value:"Function Expressions",id:"function-expressions",level:4},{value:"Arrow Function Expressions",id:"arrow-function-expressions",level:4},{value:"Object Methods",id:"object-methods",level:4},{value:"Reanimated terms",id:"reanimated-terms",level:3},{value:"[Experimental] Worklet Context Objects",id:"experimental-worklet-context-objects",level:4},{value:"[Experimental] Worklet Classes",id:"experimental-worklet-classes",level:4},{value:"Autoworkletization",id:"autoworkletization",level:2},{value:"Referencing worklets",id:"referencing-worklets",level:3},{value:"Objects aggregating worklets",id:"objects-aggregating-worklets",level:3},{value:"[Experimental] Workletizing whole files",id:"experimental-workletizing-whole-files",level:3},{value:"Limits of autoworkletization",id:"limits-of-autoworkletization",level:2},{value:"Imports",id:"imports",level:3},{value:"Custom hooks",id:"custom-hooks",level:3},{value:"Expressions",id:"expressions",level:3},{value:"Pitfalls",id:"pitfalls",level:2},{value:"Hoisting worklets",id:"hoisting-worklets",level:3},{value:"Notes",id:"notes",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"reanimated-babel-plugin",children:"Reanimated Babel Plugin"})}),"\n",(0,i.jsx)(n.h2,{id:"what-is-reanimated-babel-plugin",children:"What is Reanimated Babel Plugin?"}),"\n",(0,i.jsxs)(n.p,{children:["The Reanimated Babel Plugin transforms your code so that it can run on the ",(0,i.jsx)(n.a,{href:"/docs/fundamentals/glossary#ui-thread",children:"UI thread"}),". It looks for functions marked with a ",(0,i.jsx)(n.code,{children:"'worklet';"})," directive and converts them into serializable objects. We call this process ",(0,i.jsx)(n.a,{href:"/docs/fundamentals/glossary#to-workletize",children:"workletization"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"In short, a worklet is:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A function that contains a ",(0,i.jsx)(n.code,{children:"'worklet'"})," directive at its very top, i.e.:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function foo() {\n  'worklet';\n  console.log('Hello from worklet');\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A function that is ",(0,i.jsx)(n.em,{children:"autoworkletizable"}),", i.e.:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"useAnimatedStyle(() => {\n  // This function will be ran on the UI thread,\n  // hence it's in a workletizable context and will be\n  // autoworkletized. You don't need to add the 'worklet' directive here.\n  return {\n    width: 100,\n  };\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"what-can-be-a-worklet",children:"What can be a worklet?"}),"\n",(0,i.jsx)(n.h3,{id:"javascript-terms",children:"JavaScript terms"}),"\n",(0,i.jsx)(n.p,{children:"Reanimated Babel Plugin supports the following terms as worklets:"}),"\n",(0,i.jsx)(n.h4,{id:"function-declarations",children:"Function Declarations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function foo() {\n  'worklet';\n  console.log('Hello from FunctionDeclaration');\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"function-expressions",children:"Function Expressions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const foo = function () {\n  'worklet';\n  console.log('Hello from FunctionExpression');\n};\n"})}),"\n",(0,i.jsx)(n.h4,{id:"arrow-function-expressions",children:"Arrow Function Expressions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const foo = () => {\n  'worklet';\n  console.log('Hello from ArrowFunctionExpression');\n};\n"})}),"\n",(0,i.jsx)(n.h4,{id:"object-methods",children:"Object Methods"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const obj = {\n  foo() {\n    'worklet';\n    console.log('Hello from ObjectMethod');\n  },\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"reanimated-terms",children:"Reanimated terms"}),"\n",(0,i.jsx)(n.h4,{id:"experimental-worklet-context-objects",children:"[Experimental] Worklet Context Objects"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Object methods"})," called on UI thread lose their ",(0,i.jsx)(n.code,{children:"this"})," binding."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const obj = {\n  foo: 1,\n  bar() {\n    'worklet';\n    console.log(this.foo); // undefined - the binding was lost.\n  },\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Worklet Context Objects"})," are special terms that preserve that binding. Don't mistake them for objects created with ",(0,i.jsx)(n.code,{children:"useSharedValue"}),". All changes to Worklet Context Objects on the UI thread are visible only on the UI thread. The same applies to the JS thread."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const obj = {\n  __workletContextObject: true,\n  foo: 1,\n  bar() {\n    console.log(this.foo);\n  },\n};\n\nobj.foo = 2;\nobj.bar(); // Logs 2\nrunOnUI(() => obj.bar())(); // Logs 1\n\nrunOnUI(() => (obj.foo = 3))();\nobj.bar(); // Logs 2\nrunOnUI(() => obj.bar())(); // Logs 3\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"__workletContextObject"})," is a special property that marks an object as a Worklet Context Object. It's value doesn't matter, but it's a good practice to use ",(0,i.jsx)(n.code,{children:"true"})," as a value. ",(0,i.jsx)(n.code,{children:"'worklet'"})," directive in methods will be ignored if the object has this property."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const workletContextObject = {\n  __workletContextObject: true,\n  message: 'Hello from WorkletContextObject',\n  foo() {\n    console.log(this.message);\n  },\n};\n"})}),"\n",(0,i.jsx)(n.h4,{id:"experimental-worklet-classes",children:"[Experimental] Worklet Classes"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/facebook/hermes",children:"Hermes"}),", the JavaScript engine used by React Native, doesn't support classes. Class syntax requires ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Polyfill_%28programming%29",children:"polyfilling"})," before it can be used, which is problematic for the UI thread. To work around this, we coined the term of ",(0,i.jsx)(n.strong,{children:"Worklet Classes"}),". Worklet classes can be instantiated on the UI thread."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"__workletClass"})," is a special property that marks a class as a Worklet Class. It's value doesn't matter, but it's a good practice to use ",(0,i.jsx)(n.code,{children:"true"})," as a value. ",(0,i.jsx)(n.code,{children:"'worklet'"})," directive in methods will be ignored if the class has this property."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"class Clazz {\n  __workletClass = true;\n  message = 'Hello from WorkletClass';\n  foo() {\n    console.log(this.message);\n  }\n}\n\nrunOnUI(() => new Clazz().foo())(); // Logs 'Hello from WorkletClass'\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Pitfalls:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Worklet Classes don't support inheritance."}),"\n",(0,i.jsx)(n.li,{children:"Worklet Classes don't support static methods and properties."}),"\n",(0,i.jsx)(n.li,{children:"Class instances cannot be shared between JS and UI threads."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"autoworkletization",children:"Autoworkletization"}),"\n",(0,i.jsxs)(n.p,{children:["To reduce boilerplate code and provide a safer API, Reanimated Babel Plugin detects automatically whether a function should be workletized. Thanks to that, you don't need to add the ",(0,i.jsx)(n.code,{children:"'worklet'"})," directive to your callbacks:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const style = useAnimatedStyle(() => {\n  // You don't need to add the 'worklet' directive here,\n  // since plugin detects this callback as autoworkletizable.\n  return {\n    width: 100,\n  };\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This isn't limited to ",(0,i.jsx)(n.code,{children:"useAnimatedStyle"})," hook - Reanimated Babel Plugin autoworkletizes all callbacks for the API of Reanimated. The whole list can be found in the ",(0,i.jsx)(n.a,{href:"https://github.com/software-mansion/react-native-reanimated/blob/main/packages/react-native-worklets/plugin/src/autoworkletization.ts",children:"plugin source code"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Keep in mind that in more advanced use cases, you might still need to manually mark a function as a worklet."}),"\n",(0,i.jsx)(n.h3,{id:"referencing-worklets",children:"Referencing worklets"}),"\n",(0,i.jsxs)(n.p,{children:["You can define worklets ",(0,i.jsx)(n.strong,{children:"before"})," they are used and the plugin will autoworkletize them too:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function foo() {\n  // You don't need to add\n  // the 'worklet' directive here.\n  return { width: 100 };\n}\n\n// You don't need to define an inline function here,\n// a reference is enough.\nconst style = useAnimatedStyle(foo);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"objects-aggregating-worklets",children:"Objects aggregating worklets"}),"\n",(0,i.jsxs)(n.p,{children:["In some APIs, like ",(0,i.jsx)(n.code,{children:"useAnimatedScrollHandler"})," you can pass an object that contains worklets instead of a function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const handlerObject = {\n  // You don't need to mark these methods as worklets.\n  onBeginDrag() {\n    console.log('Dragging...');\n  },\n  onScroll() {\n    console.log('Scrolling...');\n  },\n};\n\nconst handler = useAnimatedScrollHandler(handlerObject);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"experimental-workletizing-whole-files",children:"[Experimental] Workletizing whole files"}),"\n",(0,i.jsxs)(n.p,{children:["You can mark a file as a workletizable file by adding the ",(0,i.jsx)(n.code,{children:"'worklet'"})," directive to the top of the file."]}),"\n",(0,i.jsxs)(n.p,{children:["This will workletize all ",(0,i.jsx)(n.em,{children:"top-level"})," ",(0,i.jsx)(n.a,{href:"#javascript-terms",children:"JavaScript terms"})," and ",(0,i.jsx)(n.a,{href:"#reanimated-terms",children:"Reanimated terms"})," automatically. It can come in handy for files that contain multiple worklets."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// file.ts\n'worklet';\n\nfunction foo() {\n  // Function 'foo' will be autoworkletized.\n  return { width: 100 };\n}\n\nfunction bar() {\n  // Function 'bar' will be autoworkletized.\n  function foobar() {\n    // Function 'foobar' won't since it's not defined in top-level scope.\n    console.log(\"I'm not a worklet\");\n  }\n  return { width: 100 };\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"limits-of-autoworkletization",children:"Limits of autoworkletization"}),"\n",(0,i.jsx)(n.p,{children:"The plugin cannot infer whether a function is autoworkletizable or not in some contexts."}),"\n",(0,i.jsx)(n.h3,{id:"imports",children:"Imports"}),"\n",(0,i.jsxs)(n.p,{children:["When importing a function from another file or a module and using it as a worklet, you must manually add the ",(0,i.jsx)(n.code,{children:"'worklet'"})," directive to the function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// foo.ts\nimport { bar } from './bar';\n// ...\nconst style = useAnimatedStyle(bar);\n\n// bar.ts\nexport function bar() {\n  'worklet'; // Won't work without it.\n  return {\n    width: 100,\n  };\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"custom-hooks",children:"Custom hooks"}),"\n",(0,i.jsx)(n.p,{children:"Currently Reanimated hasn't exposed APIs that would allow you to register your custom hooks for callback workletization. This however, might change in the future."}),"\n",(0,i.jsx)(n.h3,{id:"expressions",children:"Expressions"}),"\n",(0,i.jsxs)(n.p,{children:["A function won't get automatically workletized when it's a result of an expression. You have to add the ",(0,i.jsx)(n.code,{children:"'worklet';"})," directive to make it work:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const foo = someCondition\n  ? () => {\n      'worklet'; // Won't work without it.\n      return { width: 100 };\n    }\n  : () => {\n      'worklet'; // Won't work without it.\n      return { width: 200 };\n    };\n\nconst style = useAnimatedStyle(foo);\n"})}),"\n",(0,i.jsx)(n.p,{children:"In such cases we recommend either handling the conditional logic in the worklet itself or refactoring your code to eliminate the need for conditional worklets."}),"\n",(0,i.jsx)(n.h2,{id:"pitfalls",children:"Pitfalls"}),"\n",(0,i.jsx)(n.p,{children:"There are some patterns that won't work with the plugin."}),"\n",(0,i.jsx)(n.h3,{id:"hoisting-worklets",children:"Hoisting worklets"}),"\n",(0,i.jsx)(n.p,{children:"Worklets aren't hoisted. This means that you can't use worklets before they are defined:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// The following line crashes,\n// even though 'foo' is marked as a worklet.\nconst style = useAnimatedStyle(foo);\n\nfunction foo() {\n  'worklet';\n  return { width: 100 };\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,i.jsxs)(n.p,{children:["Babel is a powerful tool that can be explored to implement numerous useful features. If you feel like Reanimated Babel plugin could make use of some new functionality or that its pitfalls are too severe, feel free to let us know on ",(0,i.jsx)(n.a,{href:"https://github.com/software-mansion/react-native-reanimated/",children:"GitHub"}),", via an issue or a discussion thread - and as always, PRs are welcome!"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},30620:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var o=t(39471);const i={},s=o.createContext(i);function l(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);