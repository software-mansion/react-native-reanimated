"use strict";(self.webpackChunkdocs_reanimated=self.webpackChunkdocs_reanimated||[]).push([[6900],{30620:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>o});var t=a(39471);const i={},s=t.createContext(i);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(s.Provider,{value:n},e.children)}},51509:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/sv-interruption-74d74b266b4840a5f3ebc4cb7779c90f.gif"},55419:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/sv-spring-8af0692299a5863f1b8cef55e187431e.gif"},57437:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"fundamentals/shared-values","title":"Shared Values","description":"Shared Values are among the fundamental concepts behind Reanimated 2.0.","source":"@site/versioned_docs/version-2.x/fundamentals/shared-values.md","sourceDirName":"fundamentals","slug":"/fundamentals/shared-values","permalink":"/react-native-reanimated/docs/2.x/fundamentals/shared-values","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-reanimated/edit/main/packages/docs-reanimated/versioned_docs/version-2.x/fundamentals/shared-values.md","tags":[],"version":"2.x","frontMatter":{"id":"shared-values","title":"Shared Values","sidebar_label":"Shared Values"},"sidebar":"docs","previous":{"title":"Worklets","permalink":"/react-native-reanimated/docs/2.x/fundamentals/worklets"},"next":{"title":"Animations","permalink":"/react-native-reanimated/docs/2.x/fundamentals/animations"}}');var i=a(47671),s=a(30620);const r={id:"shared-values",title:"Shared Values",sidebar_label:"Shared Values"},o=void 0,d={},l=[{value:"Carrying data",id:"carrying-data",level:2},{value:"Reactiveness with Shared Values",id:"reactiveness-with-shared-values",level:2},{value:"Driving animations",id:"driving-animations",level:2},{value:"Animation progress",id:"animation-progress",level:3},{value:"Interrupting animations",id:"interrupting-animations",level:3},{value:"Cancelling animations",id:"cancelling-animations",level:3},{value:"Shared Values vs Animated.Value",id:"shared-values-vs-animatedvalue",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Shared Values are among the fundamental concepts behind Reanimated 2.0.\nIf you are familiar with React Native's ",(0,i.jsx)(n.a,{href:"https://reactnative.dev/docs/animated",children:"Animated API"})," you can compare them to ",(0,i.jsx)(n.code,{children:"Animated.Values"}),'.\nThey serve a similar purpose of carrying "animateable" data, providing a notion of reactiveness, and driving animations.\nWe will discuss each of those key roles of Shared Values in sections below.\nAt the end we present a brief overview of the differences between Shared Values and ',(0,i.jsx)(n.code,{children:"Animated.Value"})," for the readers familiar with the ",(0,i.jsx)(n.code,{children:"Animated"})," API."]}),"\n",(0,i.jsx)(n.h2,{id:"carrying-data",children:"Carrying data"}),"\n",(0,i.jsxs)(n.p,{children:["One of the primary goals of Shared Values is to provide a notion of shared memory in Reanimated 2.0 (hence their name).\nAs you might've learned in the article about ",(0,i.jsx)(n.a,{href:"/docs/2.x/fundamentals/worklets",children:"worklets"}),", Reanimated 2.0 runs animation code in a separate thread using a separate JS VM context.\nShared Values make it possible to maintain a reference to mutable data that can be read and modified securely across those threads."]}),"\n",(0,i.jsxs)(n.p,{children:["Shared Value objects serve as references to pieces of shared data that can be accessed and modified using their ",(0,i.jsx)(n.code,{children:".value"})," property.\nIt is important to remember that whether you want to access or update shared data, you should use ",(0,i.jsx)(n.code,{children:".value"})," property (one of the most common sources of mistakes in Reanimated 2 code, is to expect the Shared Value reference to return the data instead of accessing it's ",(0,i.jsx)(n.code,{children:".value"})," property)."]}),"\n",(0,i.jsx)(n.p,{children:"In order to provide secure and fast ways of accessing shared data across two threads, we had to make some tradeoffs when designing Shared Values.\nAs, during animations, updates most of the time happen on the UI thread, Shared Values are optimized to be updated and read from the UI thread.\nHence, read and writes done from the UI thread are all synchronous, which means that when running from a worklet on the UI thread, you can update the value and expect it to be updated immediately after that call.\nThe consequence of this choice is that updates made on the React Native JS thread are all asynchronous.\nInstead of those updates being immediate in such case, Reanimated core schedules the update to be performed on the UI thread, this way preventing any concurrency issues.\nWhen accessing and updating Shared Values from the React Native JS thread, it is best to think about it as if the value worked the same way as React's state.\nWe can make updates to the state, but the updates are not immediate, and in order to read the data we need to wait till the next re-render."}),"\n",(0,i.jsxs)(n.p,{children:["In order to create a Shared Value reference, you should use ",(0,i.jsx)(n.code,{children:"useSharedValue"})," hook:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const sharedVal = useSharedValue(3.1415);\n"})}),"\n",(0,i.jsx)(n.p,{children:"The Shared Value constructor hook takes a single argument which is the initial payload of the Shared Value.\nThis can be any primitive or nested data like object, array, number, string or boolean."}),"\n",(0,i.jsxs)(n.p,{children:["In order to update a Shared Value from the React Native thread or from a worklet running on the UI thread, you should set a new value onto the ",(0,i.jsx)(n.code,{children:".value"})," property."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",metastring:"{4,7}",children:"import { useSharedValue } from 'react-native-reanimated';\n\nfunction SomeComponent() {\n  const sharedVal = useSharedValue(0);\n  return (\n    <Button\n      onPress={() => (sharedVal.value = Math.random())}\n      title=\"Randomize\"\n    />\n  );\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"In the above example we update the value asynchronously from the React Native JS thread.\nUpdates can be done synchronously when making them from within a worklet, like so:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",metastring:"{7,11}",children:"import Animated, {\n  useSharedValue,\n  useAnimatedScrollHandler,\n} from 'react-native-reanimated';\n\nfunction SomeComponent({ children }) {\n  const scrollOffset = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) => {\n      scrollOffset.value = event.contentOffset.y;\n    },\n  });\n\n  return (\n    <Animated.ScrollView onScroll={scrollHandler}>\n      {children}\n    </Animated.ScrollView>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Above, the scroll handler is a worklet and runs the scroll event logic on the UI thread.\nUpdates made in that worklet are synchronous."}),"\n",(0,i.jsx)(n.h2,{id:"reactiveness-with-shared-values",children:"Reactiveness with Shared Values"}),"\n",(0,i.jsx)(n.p,{children:"Second most important aspect of Shared Values is that they provide a notion of reactiveness to Reanimated framework.\nBy that, we mean that updates made to Shared Values can trigger corresponding code execution on the UI thread, that can further result in starting animations, view updates, etc."}),"\n",(0,i.jsx)(n.p,{children:'The reactiveness layer has been designed to be fully transparent from the developer perspective.\nIt is based on the concept of Shared Values being captured by reactive worklets (called internally "mapper worklets").'}),"\n",(0,i.jsxs)(n.p,{children:["Currently, there are two ways how you can create a reactive worklet.\nThis can be done either by using ",(0,i.jsx)(n.a,{href:"/docs/2.x/api/hooks/useAnimatedStyle",children:(0,i.jsx)(n.code,{children:"useAnimatedStyle"})})," or ",(0,i.jsx)(n.a,{href:"/docs/2.x/api/hooks/useDerivedValue",children:(0,i.jsx)(n.code,{children:"useDerivedValue"})})," hooks.\nWhen a Shared Value is captured by a worklet provided to these hooks, the worklet will re-run upon the Shared Value change.\nUnder the hood, Reanimated engine builds a graph of dependencies between Shared Values and reactive worklets that allows us to only execute the code that needs to update and to make sure updates are done in the correct order.\nFor example, when we have a Shared Value ",(0,i.jsx)(n.code,{children:"x"}),", a derived value ",(0,i.jsx)(n.code,{children:"y"})," that uses ",(0,i.jsx)(n.code,{children:"x"}),", and an animated style that uses both ",(0,i.jsx)(n.code,{children:"x"})," and ",(0,i.jsx)(n.code,{children:"y"}),", we only re-run the derived value worklet when ",(0,i.jsx)(n.code,{children:"x"})," updates.\nIn such a case, we will also always run the derived value ",(0,i.jsx)(n.code,{children:"y"})," updater first prior to running the animated style updater, because the style depends on it."]}),"\n",(0,i.jsx)(n.p,{children:"Let us now look at a code example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",metastring:"{3,7,11,17}",children:"import Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n} from 'react-native-reanimated';\n\nfunction Box() {\n  const offset = useSharedValue(0);\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [{ translateX: offset.value }],\n    };\n  });\n\n  return (\n    <>\n      <Animated.View style={[styles.box, animatedStyles]} />\n      <Button\n        onPress={() => (offset.value = Math.random() * 255)}\n        title=\"Move\"\n      />\n    </>\n  );\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above code, we define ",(0,i.jsx)(n.code,{children:"offset"})," Shared Value which is used inside ",(0,i.jsx)(n.code,{children:"useAnimatedStyle"})," reactive worklet.\nThe ",(0,i.jsx)(n.code,{children:"offset"})," Shared Value is set to ",(0,i.jsx)(n.code,{children:"0"})," initially, and we added a button that updates the value using ",(0,i.jsx)(n.code,{children:"Math.random()"}),".\nThis way each time we press on the button, the ",(0,i.jsx)(n.code,{children:"offset"})," will update to a random value from ",(0,i.jsx)(n.code,{children:"0"})," to ",(0,i.jsx)(n.code,{children:"1"}),".\nSince animated style worklets are reactive, and in our case they depend on a single ",(0,i.jsx)(n.code,{children:"offset"})," Shared Variable, the worklet won't be executed except from the initial run, or unless the value is updated.\nUpon the button press, and when the value updates, Reanimated core will execute dependent worklets.\nIn our case that'd be our animated style worklet.\nAs a result, the worklet will re-execute causing the style to be updated.\nSince in ",(0,i.jsx)(n.code,{children:"useAnimatedStyle"})," we take ",(0,i.jsx)(n.code,{children:"offset"}),"'s value, multiply it by ",(0,i.jsx)(n.code,{children:"255"})," and map that to the x-translation of the view, the view will immediately be shifted to a new location that is from ",(0,i.jsx)(n.code,{children:"0"})," to ",(0,i.jsx)(n.code,{children:"255"})," pixels far from the initial view position.\nThis is what you will observe:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:a(82251).A+"",width:"640",height:"533"})}),"\n",(0,i.jsx)(n.h2,{id:"driving-animations",children:"Driving animations"}),"\n",(0,i.jsxs)(n.p,{children:["Animations in Reanimated 2 are first-class citizens, and the library comes bundled with a number of utility methods that help you run and customize animations (refer to the section about ",(0,i.jsx)(n.a,{href:"animations",children:"animations"})," to learn about the APIs in Reanimated 2 for controlling animations).\nOne of the ways for animations to be launched is by starting an animated transition of a Shared Value.\nThis can be done by wrapping the target value with one of the animation utility methods from reanimated library (e.g. ",(0,i.jsx)(n.a,{href:"/docs/2.x/api/animations/withTiming",children:(0,i.jsx)(n.code,{children:"withTiming"})})," or ",(0,i.jsx)(n.a,{href:"/docs/2.x/api/animations/withSpring",children:(0,i.jsx)(n.code,{children:"withSpring"})}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import { withTiming } from 'react-native-reanimated';\n\nsomeSharedValue.value = withTiming(50);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above code the ",(0,i.jsx)(n.code,{children:"offset"})," Shared Value instead of being set to ",(0,i.jsx)(n.code,{children:"50"})," immediately, will transition from the current value to ",(0,i.jsx)(n.code,{children:"50"})," using time-based animation.\nOf course, launching animations this way can be done both from the UI and from the React Native JS thread.\nBelow is a complete code example which is the modified version of the example from the previous section.\nHere, instead of updating the ",(0,i.jsx)(n.code,{children:"offset"})," value immediately, we perform an animated transition with a timing curve."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",metastring:"{17}",children:"import Animated, { withSpring } from 'react-native-reanimated';\n\nfunction Box() {\n  const offset = useSharedValue(0);\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [{ translateX: offset.value }],\n    };\n  });\n\n  return (\n    <>\n      <Animated.View style={[styles.box, animatedStyles]} />\n      <Button\n        onPress={() => {\n          offset.value = withSpring(Math.random() * 255);\n        }}\n        title=\"Move\"\n      />\n    </>\n  );\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The only change we made in the above code compared to the example from the previous section, is that we wrapped ",(0,i.jsx)(n.code,{children:"Math.random()"})," call that updates the ",(0,i.jsx)(n.code,{children:"offset"})," with ",(0,i.jsx)(n.code,{children:"withSpring"})," call.\nAs a result, the updates to the view's translation will be smooth:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:a(55419).A+"",width:"640",height:"533"})}),"\n",(0,i.jsxs)(n.p,{children:["If you want to learn how to customize animations or get notified when the animation is finished check the API of the animation method you want to use, e.g., ",(0,i.jsx)(n.a,{href:"/docs/2.x/api/animations/withTiming",children:(0,i.jsx)(n.code,{children:"withTiming"})})," or ",(0,i.jsx)(n.a,{href:"/docs/2.x/api/animations/withSpring",children:(0,i.jsx)(n.code,{children:"withSpring"})}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"animation-progress",children:"Animation progress"}),"\n",(0,i.jsxs)(n.p,{children:["In order to retrieve the current state of the animated transition started on a Shared Value we can access the ",(0,i.jsx)(n.code,{children:".value"})," property of the Shared Value.\nAfter the Shared Value transition is started, the ",(0,i.jsx)(n.code,{children:".value"})," property will be in sync with the animation progress.\nThat is, when the initial value is ",(0,i.jsx)(n.code,{children:"0"})," and we start animated transition using ",(0,i.jsx)(n.code,{children:"withTiming(50)"})," that will take 300ms, we should expect the reads of ",(0,i.jsx)(n.code,{children:".value"})," property to return a number from ",(0,i.jsx)(n.code,{children:"0"})," to ",(0,i.jsx)(n.code,{children:"50"})," that will correspond to the current position of the value as the animation progresses."]}),"\n",(0,i.jsx)(n.h3,{id:"interrupting-animations",children:"Interrupting animations"}),"\n",(0,i.jsx)(n.p,{children:"Thanks to the fact that Shared Values keep the state of their animated transition, we can make all animations fully interruptible.\nThis means that you can make updates to the Shared Value even if it is currently running the animation without worrying that this will cause an unexpected and sudden animation glitch.\nOverwriting the value in such a case will result in the previous animation being interrupted.\nIf the newly assigned value is a number (or anything static), that new value will be immediately assigned to the Shared Value, and the previously running animation will be cancelled.\nIn case the newly assigned value is also an animation, the previously running animation will smoothly transition into a new one.\nAnimation parameters such as velocity will transfer as well, which is particularly important in spring-based animations.\nThis allows to achieve a really smooth transform from one animation into another.\nThis behavior is demonstrated on the clip below where we just do more frequent taps on the button such that the new animation starts while the previous one is still running (there are no code changes compared to the previous example)."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:a(51509).A+"",width:"640",height:"533"})}),"\n",(0,i.jsx)(n.h3,{id:"cancelling-animations",children:"Cancelling animations"}),"\n",(0,i.jsxs)(n.p,{children:["There are cases in which we want to stop the currently running animation without starting a new one.\nIn reanimated, this can be done using the ",(0,i.jsx)(n.a,{href:"/docs/2.x/api/animations/cancelAnimation",children:(0,i.jsx)(n.code,{children:"cancelAnimation"})})," method:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import { cancelAnimation } from 'react-native-reanimated';\n\ncancelAnimation(someSharedValue);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Animations can be cancelled both from the UI and from React Native's JS thread."}),"\n",(0,i.jsx)(n.h2,{id:"shared-values-vs-animatedvalue",children:"Shared Values vs Animated.Value"}),"\n",(0,i.jsxs)(n.p,{children:["In this section we present a short summary of the differences between Shared Values and Animated.Values.\nThe goal of this comparison is not to point out weaknesses of one solution over the other, but to provide a condensed reference for people familiar with ",(0,i.jsx)(n.code,{children:"Animated"}),".\nIf you are confused about some aspects of Shared Values and expect them to work similarly to Animated Values please let us know and we will add that to the list."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"What"}),(0,i.jsx)(n.th,{children:"Animated Value"}),(0,i.jsx)(n.th,{children:"Shared Value"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Payload"}),(0,i.jsx)(n.td,{children:"Only numeric and string values are supported"}),(0,i.jsx)(n.td,{children:"Any primitive or nested data structure (like objects, arrays, strings, numbers, booleans)."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Connecting with View's props"}),(0,i.jsxs)(n.td,{children:["By passing ",(0,i.jsx)(n.code,{children:"Animated.Value"})," directly as a prop"]}),(0,i.jsxs)(n.td,{children:["Shared Values cannot be directly hooked as View's props. You should use ",(0,i.jsx)(n.code,{children:"useAnimatedStyle"})," or ",(0,i.jsx)(n.code,{children:"useAnimatedProps"})," where you can access Shared Values and return them as selected styles/props or process them to calculate the styles."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Updating values"}),(0,i.jsxs)(n.td,{children:["Using ",(0,i.jsx)(n.code,{children:"value.setValue"})," method (which is an async call when the value is using native driver)"]}),(0,i.jsxs)(n.td,{children:["By updating ",(0,i.jsx)(n.code,{children:".value"})," property. Updating ",(0,i.jsx)(n.code,{children:".value"})," is sync when running on the UI thread, or async when running on the React Native JS thread."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Reading values"}),(0,i.jsxs)(n.td,{children:["Register listener with ",(0,i.jsx)(n.code,{children:"value.addListener"})," to get all animated value updates."]}),(0,i.jsxs)(n.td,{children:["By reading ",(0,i.jsx)(n.code,{children:".value"})," property you can access the current value stored in the Shared Value (both from the UI and React Native JS thread)."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Running animations"}),(0,i.jsxs)(n.td,{children:["Use ",(0,i.jsx)(n.code,{children:"Animated.spring"}),", ",(0,i.jsx)(n.code,{children:"Animated.timing"})," (or others), pass Animated Value as an argument, and run ",(0,i.jsx)(n.code,{children:".start()"})," method to launch the animation."]}),(0,i.jsxs)(n.td,{children:["Update ",(0,i.jsx)(n.code,{children:".value"})," prop as usual while wrapping the target with one of the animation utility methods (e.g., ",(0,i.jsx)(n.code,{children:"withTiming"}),")."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Stopping animations"}),(0,i.jsxs)(n.td,{children:["Hold the reference to the animation object returned by ",(0,i.jsx)(n.code,{children:"Animated.timing"})," and similar, then call ",(0,i.jsx)(n.code,{children:"stopAnimation()"})," method on it."]}),(0,i.jsxs)(n.td,{children:["Use ",(0,i.jsx)(n.code,{children:"cancelAnimation"})," method and pass the Shared Value that runs the animation."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Interpolating"}),(0,i.jsxs)(n.td,{children:["Use ",(0,i.jsx)(n.code,{children:"interpolate()"})," member method of Animated Value."]}),(0,i.jsxs)(n.td,{children:["Use an ",(0,i.jsx)(n.code,{children:"interpolate"})," method that takes a number and config similar to Animated's interpolate, then returns an interpolated number. This can be used along with ",(0,i.jsx)(n.code,{children:"useDerivedValue"})," if you need a Shared Value that automatically tracks the interpolation of another Shared Value."]})]})]})]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},82251:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/sv-immediate-163a607a1256501020dc30d515d78647.gif"}}]);