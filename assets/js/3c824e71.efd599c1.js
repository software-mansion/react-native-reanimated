"use strict";(self.webpackChunkdocs_reanimated=self.webpackChunkdocs_reanimated||[]).push([[9266],{15454:(e,n,t)=>{t.d(n,{A:()=>a});var o=t(58343),r=t(72188);const a=()=>{const{colorScheme:e}=(0,o.Ut)();return"light"===e?l.darkText:l.lightText},l=r.A.create({lightText:{color:"var(--swm-off-white)"},darkText:{color:"var(--swm-navy-light-100)"}})},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var o=t(96540);const r={},a=o.createContext(r);function l(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),o.createElement(a.Provider,{value:n},e.children)}},41632:(e,n,t)=>{t.d(n,{A:()=>p});var o=t(55535),r=t(15782),a=t(9176),l=t(68444),s=t(72188),i=t(15454),d=t(74848);const c=o.default.createAnimatedComponent(r.A),u={code:"function UseHandlerEventExampleTsx1(event){const{offsetY}=this.__closure;offsetY.value=event.contentOffset.y;}"},h={code:"function UseHandlerEventExampleTsx2(event){const{handlers}=this.__closure;const{onScroll:onScroll}=handlers;if(onScroll){onScroll(event);}}"},f={code:'function UseHandlerEventExampleTsx3(){const{offsetY}=this.__closure;return{text:"Scroll offset: "+Math.round(offsetY.value)+"px",defaultValue:"Scroll offset: "+offsetY.value+"px"};}'};const p=function(){const e=(0,i.A)(),n=(0,o.useSharedValue)(0),t={onScroll:function(){const e=function(e){n.value=e.contentOffset.y};return e.__closure={offsetY:n},e.__workletHash=0x91a68d1fb11,e.__initData=u,e}()},{context:r,doDependenciesDiffer:s}=(0,o.useHandler)(t),p=(0,o.useEvent)(function(){const e=function(e){const{onScroll:n}=t;n&&n(e)};return e.__closure={handlers:t},e.__workletHash=0x9938ee7cde1,e.__initData=h,e}(),["onScroll"],s),x=(0,o.useAnimatedProps)(function(){const e=function(){return{text:`Scroll offset: ${Math.round(n.value)}px`,defaultValue:`Scroll offset: ${n.value}px`}};return e.__closure={offsetY:n},e.__workletHash=2714082481794,e.__initData=f,e}()),v=["#fa7f7c","#b58df1","#ffe780","#82cab2","#87cce8"].map(((e,n)=>(0,d.jsx)(a.A,{style:[m.section,{backgroundColor:e}]},n)));return(0,d.jsxs)(l.A,{style:m.container,children:[(0,d.jsx)(c,{animatedProps:x,editable:!1,style:[m.header,e]}),(0,d.jsx)(o.default.ScrollView,{onScroll:p,children:(0,d.jsx)(a.A,{style:m.container,children:v})})]})},m=s.A.create({container:{paddingHorizontal:32,height:350},header:{paddingVertical:16,paddingHorizontal:32,textAlign:"center",fontFamily:"Aeonik",marginTop:"-1px"},section:{height:150,borderRadius:20,marginVertical:10,marginHorizontal:20}})},47486:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>f,frontMatter:()=>i,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"advanced/useHandler","title":"useHandler","description":"useHandler is a low-level hook. It returns a context object and a value that tells you if the worklet needs to be rebuilt. You can use it to create custom event handler hooks, like useScrollViewOffset or useAnimatedScrollHandler.","source":"@site/docs/advanced/useHandler.mdx","sourceDirName":"advanced","slug":"/advanced/useHandler","permalink":"/react-native-reanimated/docs/next/advanced/useHandler","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-reanimated/edit/main/packages/docs-reanimated/docs/advanced/useHandler.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"useEvent","permalink":"/react-native-reanimated/docs/next/advanced/useEvent"},"next":{"title":"useComposedEventHandler","permalink":"/react-native-reanimated/docs/next/advanced/useComposedEventHandler"}}');var r=t(74848),a=t(28453),l=t(41632),s=t(88907);const i={sidebar_position:5},d="useHandler",c={},u=[{value:"Reference",id:"reference",level:2},{value:"Arguments",id:"arguments",level:3},{value:"<code>handlers</code>",id:"handlers",level:4},{value:"<code>dependencies</code> <Optional></Optional>",id:"dependencies-",level:4},{value:"Returns",id:"returns",level:3},{value:"Example",id:"example",level:2},{value:"Platform compatibility",id:"platform-compatibility",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components},{Details:t,InteractiveExample:o,Optional:i,PlatformCompatibility:d}=n;return t||p("Details",!0),o||p("InteractiveExample",!0),i||p("Optional",!0),d||p("PlatformCompatibility",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"usehandler",children:"useHandler"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useHandler"})," is a low-level hook. It returns a context object and a value that tells you if the worklet needs to be rebuilt. You can use it to create custom event handler hooks, like ",(0,r.jsx)(n.a,{href:"/docs/next/scroll/useScrollViewOffset/",children:(0,r.jsx)(n.code,{children:"useScrollViewOffset"})})," or ",(0,r.jsx)(n.a,{href:"/docs/next/scroll/useAnimatedScrollHandler/",children:(0,r.jsx)(n.code,{children:"useAnimatedScrollHandler"})}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { useEvent, useHandler } from 'react-native-reanimated';\n\nfunction useAnimatedPagerScrollHandler(handlers, dependencies) {\n  // highlight-start\n  const { context, doDependenciesDiffer, useWeb } = useHandler(\n    handlers,\n    dependencies\n  );\n  // highlight-end\n\n  return useEvent(\n    (event) => {\n      'worklet';\n      const { onPageScroll } = handlers;\n\n      if (onPageScroll && event.eventName.endsWith('onPageScroll')) {\n        onPageScroll(event, context);\n      }\n    },\n    // highlight-start\n    ['onPageScroll'],\n    doDependenciesDiffer\n    // highlight-end\n  );\n}\n"})}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Type definitions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function useHandler<\n  Event extends object,\n  Context extends Record<string, unknown>\n>(\n  handlers: GeneralHandlers<Event, Context>,\n  dependencies?: DependencyList\n): UseHandlerContext<Context>;\n\ninterface UseHandlerContext<Context extends Record<string, unknown>> {\n  context: Context;\n  doDependenciesDiffer: boolean;\n  useWeb: boolean;\n}\n\ninterface GeneralHandler<\n  Event extends object,\n  Context extends Record<string, unknown>\n> {\n  (event: ReanimatedEvent<Event>, context: Context): void;\n}\n"})})]}),"\n",(0,r.jsx)(n.h3,{id:"arguments",children:"Arguments"}),"\n",(0,r.jsx)(n.h4,{id:"handlers",children:(0,r.jsx)(n.code,{children:"handlers"})}),"\n",(0,r.jsx)(n.p,{children:"Object containing custom keys matching native event names.\nThe values in the object should be individual worklets.\nEach of the worklets will be triggered when the corresponding event is dispatched on the connected animated component."}),"\n",(0,r.jsx)(n.p,{children:"Each of the event worklets will receive the following parameters when called:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"event"})," - event object.\nThe payload can differ depending on the type of the event."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"context"})," - plain JS object that can be used to store some state.\nThis object will persist in between event occurrences and you can read and write any data to it.\nWhen there are several event handlers provided in a form of an object of worklets, the ",(0,r.jsx)(n.code,{children:"context"})," object will be shared in between the worklets allowing them to communicate with each other."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"dependencies-",children:[(0,r.jsx)(n.code,{children:"dependencies"})," ",(0,r.jsx)(i,{})]}),"\n",(0,r.jsx)(n.p,{children:"An optional array of dependencies."}),"\n",(0,r.jsxs)(n.p,{children:["Only relevant when using Reanimated ",(0,r.jsx)(n.a,{href:"/docs/next/guides/web-support/#web-without-the-babel-plugin",children:"without the Babel plugin on the Web."})]}),"\n",(0,r.jsx)(n.h3,{id:"returns",children:"Returns"}),"\n",(0,r.jsxs)(n.p,{children:["The hook returns a context that will be reused by event handlers and value that indicates whether worklets should be rebuilt. If different implementation is needed for web, ",(0,r.jsx)(n.code,{children:"useWeb"})," boolean is returned to check for web environment"]}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n","\n",(0,r.jsx)(o,{src:s.A,component:l.A}),"\n",(0,r.jsxs)(n.p,{children:["This example can be more easily implemented using ",(0,r.jsx)(n.a,{href:"/docs/next/scroll/useScrollViewOffset/",children:(0,r.jsx)(n.code,{children:"useScrollViewOffset"})}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"platform-compatibility",children:"Platform compatibility"}),"\n",(0,r.jsx)(d,{android:!0,ios:!0,web:!0})]})}function f(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}function p(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},68444:(e,n,t)=>{t.d(n,{A:()=>f});var o=t(58168),r=t(98587),a=t(96540),l=t(72188),s=t(9176),i=t(7162),d=["style"],c=i.A&&window.CSS&&window.CSS.supports&&window.CSS.supports("top: constant(safe-area-inset-top)")?"constant":"env",u=a.forwardRef(((e,n)=>{var t=e.style,i=(0,r.A)(e,d);return a.createElement(s.A,(0,o.A)({},i,{ref:n,style:l.A.compose(h.root,t)}))}));u.displayName="SafeAreaView";var h=l.A.create({root:{paddingTop:c+"(safe-area-inset-top)",paddingRight:c+"(safe-area-inset-right)",paddingBottom:c+"(safe-area-inset-bottom)",paddingLeft:c+"(safe-area-inset-left)"}});const f=u},88907:(e,n,t)=>{t.d(n,{A:()=>o});const o="import React, { useEffect } from 'react';\nimport Animated, {\n  useHandler,\n  useEvent,\n  useSharedValue,\n  useAnimatedProps,\n  type ScrollEvent,\n} from 'react-native-reanimated';\nimport { TextInput, SafeAreaView, View, StyleSheet } from 'react-native';\nimport useThemedTextStyle from '@site/src/hooks/useThemedTextStyle';\n\nconst AnimatedTextInput = Animated.createAnimatedComponent(TextInput);\n\nfunction UseHandlerExample() {\n  const textColor = useThemedTextStyle();\n  const offsetY = useSharedValue(0);\n\n  const handlers = {\n    onScroll: (event: ScrollEvent) => {\n      'worklet';\n      offsetY.value = event.contentOffset.y;\n    },\n  };\n\n  const { context, doDependenciesDiffer } = useHandler(handlers);\n\n  const scrollHandler = useEvent(\n    (event: ScrollEvent) => {\n      'worklet';\n      const { onScroll } = handlers;\n      if (onScroll) {\n        onScroll(event);\n      }\n    },\n    ['onScroll'],\n    doDependenciesDiffer\n  );\n\n  const animatedProps = useAnimatedProps(() => {\n    return {\n      text: `Scroll offset: ${Math.round(offsetY.value)}px`,\n      defaultValue: `Scroll offset: ${offsetY.value}px`,\n    };\n  });\n\n  const BRAND_COLORS = ['#fa7f7c', '#b58df1', '#ffe780', '#82cab2', '#87cce8'];\n\n  const content = BRAND_COLORS.map((color, index) => (\n    <View\n      key={index}\n      style={[\n        styles.section,\n        {\n          backgroundColor: color,\n        },\n      ]}\n    />\n  ));\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <AnimatedTextInput\n        animatedProps={animatedProps}\n        editable={false}\n        style={[styles.header, textColor]}\n      />\n      <Animated.ScrollView onScroll={scrollHandler}>\n        <View style={styles.container}>{content}</View>\n      </Animated.ScrollView>\n    </SafeAreaView>\n  );\n}\n\nexport default UseHandlerExample;\n\nconst styles = StyleSheet.create({\n  container: {\n    paddingHorizontal: 32,\n    height: 350,\n  },\n  header: {\n    paddingVertical: 16,\n    paddingHorizontal: 32,\n    textAlign: 'center',\n    fontFamily: 'Aeonik',\n    marginTop: '-1px',\n  },\n  section: {\n    height: 150,\n    borderRadius: 20,\n    marginVertical: 10,\n    marginHorizontal: 20,\n  },\n});\n"}}]);