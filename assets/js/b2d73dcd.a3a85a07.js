"use strict";(self.webpackChunkdocs_reanimated=self.webpackChunkdocs_reanimated||[]).push([[8828],{30620:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var a=n(39471);const i={},c=a.createContext(i);function o(e){const t=a.useContext(c);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(c.Provider,{value:t},e.children)}},47507:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"clock","title":"Clock","description":"Original Animated API makes an \\"animation\\" object a first class citizen.","source":"@site/versioned_docs/version-1.x/clock.md","sourceDirName":".","slug":"/clock","permalink":"/react-native-reanimated/docs/1.x/clock","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-reanimated/edit/main/docs/docs-reanimated/versioned_docs/version-1.x/clock.md","tags":[],"version":"1.x","frontMatter":{"id":"clock","title":"Clock","sidebar_label":"Clock"},"sidebar":"docs","previous":{"title":"Value","permalink":"/react-native-reanimated/docs/1.x/value"},"next":{"title":"Timing","permalink":"/react-native-reanimated/docs/1.x/animations/timing"}}');var i=n(47671),c=n(30620);const o={id:"clock",title:"Clock",sidebar_label:"Clock"},s=void 0,r={},d=[];function l(e){const t={code:"code",p:"p",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Original ",(0,i.jsx)(t.code,{children:"Animated"}),' API makes an "animation" object a first class citizen.\n',(0,i.jsx)(t.code,{children:"Animation"})," object has many features and therefore requires quite a few JS<->Native bridge methods to be managed properly.\nIn ",(0,i.jsx)(t.code,{children:"react-native-reanimated"}),", clocks aim to replace that by providing more of a low level abstraction but also since clock nodes behave much like the animated values they make the implementation much less complex."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"Animated.Clock"})," node is a special type of ",(0,i.jsx)(t.code,{children:"Animated.Value"})," that can be updated in each frame to the timestamp of the current frame. When we take ",(0,i.jsx)(t.code,{children:"Clock"})," node as an input, the value it returns is the current frame timestamp in milliseconds. Using special methods, clock nodes can be stopped and started and we can also test if clock has been started."]}),"\n",(0,i.jsxs)(t.p,{children:["Because ",(0,i.jsx)(t.code,{children:"Animated.Clock"})," just extends the ",(0,i.jsx)(t.code,{children:"Animated.Value"})," you can use it in the same places (operations) where you can pass any type of animated node."]})]})}function m(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);