"use strict";(self.webpackChunkreact_native_reanimated_docs=self.webpackChunkreact_native_reanimated_docs||[]).push([[9891],{4283:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>d,toc:()=>l});var o=n(7462),a=(n(7294),n(3905));const r={id:"code",title:"Animated.Code",sidebar_label:"Animated.Code"},i=void 0,d={unversionedId:"code",id:"version-1.x/code",title:"Animated.Code",description:"Animated.Code component allows you to define reanimated nodes that you want to execute when their input nodes updates, but aren't necessarily strictly related to some view properties and hence it does not feel right to place them under translate or other prop of an Animated.View. This component renders null, so you can place it in any place you want in your render method. It is required that your code is put inside component as we rely on componentDidMount and componentWillUnmount callbacks to install and cleanup animated nodes. Note that the code you put is going to be executed only once. We currently have no way of telling if your code changes and so it will only be run in componentDidMount. If you wish for your reanimated nodes to be updated when the component updates, you can update the key property of the Animated.Code component, which will effectively unmount the old and mount the new versions of it in the React tree. You can provide dependencies key which works just like the second argument in useCode.",source:"@site/versioned_docs/version-1.x/code.md",sourceDirName:".",slug:"/code",permalink:"/react-native-reanimated/docs/1.x/code",draft:!1,tags:[],version:"1.x",frontMatter:{id:"code",title:"Animated.Code",sidebar_label:"Animated.Code"},sidebar:"version-1.x/docs",previous:{title:"View, Props, etc",permalink:"/react-native-reanimated/docs/1.x/view"}},s={},l=[{value:"<code>Animated.useCode</code>",id:"animatedusecode",level:2}],c={toc:l};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Animated.Code")," component allows you to define reanimated nodes that you want to execute when their input nodes updates, but aren't necessarily strictly related to some view properties and hence it does not feel right to place them under ",(0,a.kt)("inlineCode",{parentName:"p"},"translate")," or other prop of an ",(0,a.kt)("inlineCode",{parentName:"p"},"Animated.View"),". This component renders ",(0,a.kt)("inlineCode",{parentName:"p"},"null"),", so you can place it in any place you want in your render method. It is required that your code is put inside component as we rely on ",(0,a.kt)("inlineCode",{parentName:"p"},"componentDidMount")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"componentWillUnmount")," callbacks to install and cleanup animated nodes. Note that the code you put is going to be executed only once. We currently have no way of telling if your code changes and so it will only be run in ",(0,a.kt)("inlineCode",{parentName:"p"},"componentDidMount"),". If you wish for your reanimated nodes to be updated when the component updates, you can update the ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," property of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Animated.Code")," component, which will effectively unmount the old and mount the new versions of it in the React tree. You can provide ",(0,a.kt)("inlineCode",{parentName:"p"},"dependencies")," key which works just like the second argument in ",(0,a.kt)("inlineCode",{parentName:"p"},"useCode"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"<Animated.Code>\n  {() =>\n    block([\n      set(this.transX1, add(multiply(-1, this._transX))),\n      set(this.transX2, add(multiply(-2, this._transX), 120)),\n      set(this.transX3, sub(multiply(2, this._transX), 120)),\n      set(this.transX4, add(multiply(1, this._transX))),\n    ])\n  }\n</Animated.Code>\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"<Animated.Code\n  exec={block([\n    set(this.transX1, add(multiply(-1, this._transX))),\n    set(this.transX2, add(multiply(-2, this._transX), 120)),\n    set(this.transX3, sub(multiply(2, this._transX), 120)),\n    set(this.transX4, add(multiply(1, this._transX))),\n  ])}\n/>\n")),(0,a.kt)("h2",{id:"animatedusecode"},(0,a.kt)("inlineCode",{parentName:"h2"},"Animated.useCode")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"useCode")," hook acts as an alternative to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Animated.Code")," component."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"Animated.useCode(\n    () => Node | Node[] | boolean | null | undefined,\n    [...dependencies]\n)\n")),(0,a.kt)("p",null,"It's passed as 1st parameter a factory function that should return an optional animated node, or array of nodes (which will be then placed in a ",(0,a.kt)("inlineCode",{parentName:"p"},"block")," node), and as 2nd parameter, an array of dependencies. It will update that node, both when the component mounts and every time a value in that array changes. It does nothing on versions of React Native that don't support hooks (<0.59)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const [animated, setAnimated] = React.useState(false);\nconst [offset, setOffset] = React.useState(20);\n\nAnimated.useCode(\n  () =>\n    animated && [\n      //...\n      set(transX1, add(_transX, offset)),\n    ],\n  [animated, offset]\n);\n")),(0,a.kt)("p",null,"We recommend to use ",(0,a.kt)("inlineCode",{parentName:"p"},"useCode()")," with the ",(0,a.kt)("inlineCode",{parentName:"p"},"react-hooks/exhaustive-deps")," ",(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/eslint-plugin-react-hooks"},"eslint rule"),"."))}p.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),l=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return o.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,c=d(e,["components","mdxType","originalType","parentName"]),u=l(n),m=a,h=u["".concat(s,".").concat(m)]||u[m]||p[m]||r;return n?o.createElement(h,i(i({ref:t},c),{},{components:n})):o.createElement(h,i({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var d={};for(var s in t)hasOwnProperty.call(t,s)&&(d[s]=t[s]);d.originalType=e,d.mdxType="string"==typeof e?e:a,i[1]=d;for(var l=2;l<r;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);